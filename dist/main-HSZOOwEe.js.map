{"version":3,"file":"main-HSZOOwEe.js","sources":["../node_modules/@petamoriken/float16/src/_util/primordials.mjs","../node_modules/@petamoriken/float16/src/_util/arrayIterator.mjs","../node_modules/@petamoriken/float16/src/_util/converter.mjs","../node_modules/@petamoriken/float16/src/DataView.mjs","../node_modules/xml-utils/get-attribute.js","../node_modules/xml-utils/index-of-match.js","../node_modules/xml-utils/index-of-match-end.js","../node_modules/xml-utils/count-substring.js","../node_modules/xml-utils/find-tag-by-name.js","../node_modules/xml-utils/find-tags-by-name.js","../node_modules/geotiff/dist-module/globals.js","../node_modules/geotiff/dist-module/rgb.js","../node_modules/geotiff/dist-module/compression/index.js","../node_modules/geotiff/dist-module/resample.js","../node_modules/geotiff/dist-module/geotiffimage.js","../node_modules/geotiff/dist-module/dataview64.js","../node_modules/geotiff/dist-module/dataslice.js","../node_modules/geotiff/dist-module/pool.js","../node_modules/geotiff/dist-module/source/httputils.js","../node_modules/geotiff/dist-module/source/basesource.js","../node_modules/quick-lru/index.js","../node_modules/geotiff/dist-module/utils.js","../node_modules/geotiff/dist-module/source/blockedsource.js","../node_modules/geotiff/dist-module/source/client/base.js","../node_modules/geotiff/dist-module/source/client/fetch.js","../node_modules/geotiff/dist-module/source/client/xhr.js","../__vite-browser-external","../node_modules/geotiff/dist-module/source/client/http.js","../node_modules/geotiff/dist-module/source/remote.js","../node_modules/geotiff/dist-module/source/filereader.js","../node_modules/geotiff/dist-module/geotiff.js","../src/utils/DeferredPromise.js","../src/formats/perkinElmer.js","../src/utils/Converters.js","../src/utils/osdMonkeyPatch.js","../src/GeoTIFFTileSource.js","../src/main.js"],"sourcesContent":["/* eslint-disable no-restricted-globals, no-restricted-syntax */\n/* global SharedArrayBuffer */\n\nimport { CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT } from \"./messages.mjs\";\n\n/** @type {<T extends (...args: any) => any>(target: T) => (thisArg: ThisType<T>, ...args: any[]) => any} */\nfunction uncurryThis(target) {\n  return (thisArg, ...args) => {\n    return ReflectApply(target, thisArg, args);\n  };\n}\n\n/** @type {(target: any, key: string | symbol) => (thisArg: any, ...args: any[]) => any} */\nfunction uncurryThisGetter(target, key) {\n  return uncurryThis(\n    ReflectGetOwnPropertyDescriptor(\n      target,\n      key\n    ).get\n  );\n}\n\n// Reflect\nexport const {\n  apply: ReflectApply,\n  construct: ReflectConstruct,\n  defineProperty: ReflectDefineProperty,\n  get: ReflectGet,\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor,\n  getPrototypeOf: ReflectGetPrototypeOf,\n  has: ReflectHas,\n  ownKeys: ReflectOwnKeys,\n  set: ReflectSet,\n  setPrototypeOf: ReflectSetPrototypeOf,\n} = Reflect;\n\n// Proxy\nexport const NativeProxy = Proxy;\n\n// Number\nexport const {\n  EPSILON,\n  MAX_SAFE_INTEGER,\n  isFinite: NumberIsFinite,\n  isNaN: NumberIsNaN,\n} = Number;\n\n// Symbol\nexport const {\n  iterator: SymbolIterator,\n  species: SymbolSpecies,\n  toStringTag: SymbolToStringTag,\n  for: SymbolFor,\n} = Symbol;\n\n// Object\nexport const NativeObject = Object;\nexport const {\n  create: ObjectCreate,\n  defineProperty: ObjectDefineProperty,\n  freeze: ObjectFreeze,\n  is: ObjectIs,\n} = NativeObject;\nconst ObjectPrototype = NativeObject.prototype;\n/** @type {(object: object, key: PropertyKey) => Function | undefined} */\nexport const ObjectPrototype__lookupGetter__ = /** @type {any} */ (ObjectPrototype).__lookupGetter__\n  ? uncurryThis(/** @type {any} */ (ObjectPrototype).__lookupGetter__)\n  : (object, key) => {\n    if (object == null) {\n      throw NativeTypeError(\n        CANNOT_CONVERT_UNDEFINED_OR_NULL_TO_OBJECT\n      );\n    }\n\n    let target = NativeObject(object);\n    do {\n      const descriptor = ReflectGetOwnPropertyDescriptor(target, key);\n      if (descriptor !== undefined) {\n        if (ObjectHasOwn(descriptor, \"get\")) {\n          return descriptor.get;\n        }\n\n        return;\n      }\n    } while ((target = ReflectGetPrototypeOf(target)) !== null);\n  };\n/** @type {(object: object, key: PropertyKey) => boolean} */\nexport const ObjectHasOwn = /** @type {any} */ (NativeObject).hasOwn ||\n  uncurryThis(ObjectPrototype.hasOwnProperty);\n\n// Array\nconst NativeArray = Array;\nexport const ArrayIsArray = NativeArray.isArray;\nconst ArrayPrototype = NativeArray.prototype;\n/** @type {(array: ArrayLike<unknown>, separator?: string) => string} */\nexport const ArrayPrototypeJoin = uncurryThis(ArrayPrototype.join);\n/** @type {<T>(array: T[], ...items: T[]) => number} */\nexport const ArrayPrototypePush = uncurryThis(ArrayPrototype.push);\n/** @type {(array: ArrayLike<unknown>, ...opts: any[]) => string} */\nexport const ArrayPrototypeToLocaleString = uncurryThis(\n  ArrayPrototype.toLocaleString\n);\nexport const NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator];\n/** @type {<T>(array: T[]) => IterableIterator<T>} */\nexport const ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator);\n\n// Math\nexport const {\n  abs: MathAbs,\n  trunc: MathTrunc,\n} = Math;\n\n// ArrayBuffer\nexport const NativeArrayBuffer = ArrayBuffer;\nexport const ArrayBufferIsView = NativeArrayBuffer.isView;\nconst ArrayBufferPrototype = NativeArrayBuffer.prototype;\n/** @type {(buffer: ArrayBuffer, begin?: number, end?: number) => number} */\nexport const ArrayBufferPrototypeSlice = uncurryThis(ArrayBufferPrototype.slice);\n/** @type {(buffer: ArrayBuffer) => ArrayBuffer} */\nexport const ArrayBufferPrototypeGetByteLength = uncurryThisGetter(ArrayBufferPrototype, \"byteLength\");\n\n// SharedArrayBuffer\nexport const NativeSharedArrayBuffer = typeof SharedArrayBuffer !== \"undefined\" ? SharedArrayBuffer : null;\n/** @type {(buffer: SharedArrayBuffer) => SharedArrayBuffer} */\nexport const SharedArrayBufferPrototypeGetByteLength = NativeSharedArrayBuffer\n  && uncurryThisGetter(NativeSharedArrayBuffer.prototype, \"byteLength\");\n\n// TypedArray\n/** @typedef {Uint8Array|Uint8ClampedArray|Uint16Array|Uint32Array|Int8Array|Int16Array|Int32Array|Float32Array|Float64Array|BigUint64Array|BigInt64Array} TypedArray */\n/** @type {any} */\nexport const TypedArray = ReflectGetPrototypeOf(Uint8Array);\nconst TypedArrayFrom = TypedArray.from;\nexport const TypedArrayPrototype = TypedArray.prototype;\nexport const NativeTypedArrayPrototypeSymbolIterator = TypedArrayPrototype[SymbolIterator];\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nexport const TypedArrayPrototypeKeys = uncurryThis(TypedArrayPrototype.keys);\n/** @type {(typedArray: TypedArray) => IterableIterator<number>} */\nexport const TypedArrayPrototypeValues = uncurryThis(\n  TypedArrayPrototype.values\n);\n/** @type {(typedArray: TypedArray) => IterableIterator<[number, number]>} */\nexport const TypedArrayPrototypeEntries = uncurryThis(\n  TypedArrayPrototype.entries\n);\n/** @type {(typedArray: TypedArray, array: ArrayLike<number>, offset?: number) => void} */\nexport const TypedArrayPrototypeSet = uncurryThis(TypedArrayPrototype.set);\n/** @type {<T extends TypedArray>(typedArray: T) => T} */\nexport const TypedArrayPrototypeReverse = uncurryThis(\n  TypedArrayPrototype.reverse\n);\n/** @type {<T extends TypedArray>(typedArray: T, value: number, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeFill = uncurryThis(TypedArrayPrototype.fill);\n/** @type {<T extends TypedArray>(typedArray: T, target: number, start: number, end?: number) => T} */\nexport const TypedArrayPrototypeCopyWithin = uncurryThis(\n  TypedArrayPrototype.copyWithin\n);\n/** @type {<T extends TypedArray>(typedArray: T, compareFn?: (a: number, b: number) => number) => T} */\nexport const TypedArrayPrototypeSort = uncurryThis(TypedArrayPrototype.sort);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeSlice = uncurryThis(TypedArrayPrototype.slice);\n/** @type {<T extends TypedArray>(typedArray: T, start?: number, end?: number) => T} */\nexport const TypedArrayPrototypeSubarray = uncurryThis(\n  TypedArrayPrototype.subarray\n);\n/** @type {((typedArray: TypedArray) => ArrayBuffer)} */\nexport const TypedArrayPrototypeGetBuffer = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"buffer\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nexport const TypedArrayPrototypeGetByteOffset = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"byteOffset\"\n);\n/** @type {((typedArray: TypedArray) => number)} */\nexport const TypedArrayPrototypeGetLength = uncurryThisGetter(\n  TypedArrayPrototype,\n  \"length\"\n);\n/** @type {(target: unknown) => string} */\nexport const TypedArrayPrototypeGetSymbolToStringTag = uncurryThisGetter(\n  TypedArrayPrototype,\n  SymbolToStringTag\n);\n\n// Uint8Array\nexport const NativeUint8Array = Uint8Array;\n\n// Uint16Array\nexport const NativeUint16Array = Uint16Array;\n/** @type {Uint16ArrayConstructor[\"from\"]} */\nexport const Uint16ArrayFrom = (...args) => {\n  return ReflectApply(TypedArrayFrom, NativeUint16Array, args);\n};\n\n// Uint32Array\nexport const NativeUint32Array = Uint32Array;\n\n// Float32Array\nexport const NativeFloat32Array = Float32Array;\n\n// ArrayIterator\n/** @type {any} */\nexport const ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]());\n/** @type {<T>(arrayIterator: IterableIterator<T>) => IteratorResult<T>} */\nexport const ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next);\n\n// Generator\n/** @type {<T = unknown, TReturn = any, TNext = unknown>(generator: Generator<T, TReturn, TNext>, value?: TNext) => T} */\nexport const GeneratorPrototypeNext = uncurryThis((function* () {})().next);\n\n// Iterator\nexport const IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype);\n\n// DataView\nconst DataViewPrototype = DataView.prototype;\n/** @type {(dataView: DataView, byteOffset: number, littleEndian?: boolean) => number} */\nexport const DataViewPrototypeGetUint16 = uncurryThis(\n  DataViewPrototype.getUint16\n);\n/** @type {(dataView: DataView, byteOffset: number, value: number, littleEndian?: boolean) => void} */\nexport const DataViewPrototypeSetUint16 = uncurryThis(\n  DataViewPrototype.setUint16\n);\n\n// Error\nexport const NativeTypeError = TypeError;\nexport const NativeRangeError = RangeError;\n\n// WeakSet\n/**\n * Do not construct with arguments to avoid calling the \"add\" method\n * @type {{new <T extends {}>(): WeakSet<T>}}\n */\nexport const NativeWeakSet = WeakSet;\nconst WeakSetPrototype = NativeWeakSet.prototype;\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => Set<T>} */\nexport const WeakSetPrototypeAdd = uncurryThis(WeakSetPrototype.add);\n/** @type {<T extends {}>(set: WeakSet<T>, value: T) => boolean} */\nexport const WeakSetPrototypeHas = uncurryThis(WeakSetPrototype.has);\n\n// WeakMap\n/**\n * Do not construct with arguments to avoid calling the \"set\" method\n * @type {{new <K extends {}, V>(): WeakMap<K, V>}}\n */\nexport const NativeWeakMap = WeakMap;\nconst WeakMapPrototype = NativeWeakMap.prototype;\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => V} */\nexport const WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K) => boolean} */\nexport const WeakMapPrototypeHas = uncurryThis(WeakMapPrototype.has);\n/** @type {<K extends {}, V>(weakMap: WeakMap<K, V>, key: K, value: V) => WeakMap} */\nexport const WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set);\n","import {\n  ArrayIteratorPrototype,\n  ArrayIteratorPrototypeNext,\n  ArrayPrototypeSymbolIterator,\n  GeneratorPrototypeNext,\n  IteratorPrototype,\n  NativeArrayPrototypeSymbolIterator,\n  NativeWeakMap,\n  ObjectCreate,\n  ObjectDefineProperty,\n  ReflectGetOwnPropertyDescriptor,\n  ReflectOwnKeys,\n  SymbolIterator,\n  WeakMapPrototypeGet,\n  WeakMapPrototypeSet,\n} from \"./primordials.mjs\";\n\n/** @type {WeakMap<{}, IterableIterator<any>>} */\nconst arrayIterators = new NativeWeakMap();\n\nconst SafeIteratorPrototype = ObjectCreate(null, {\n  next: {\n    value: function next() {\n      const arrayIterator = WeakMapPrototypeGet(arrayIterators, this);\n      return ArrayIteratorPrototypeNext(arrayIterator);\n    },\n  },\n\n  [SymbolIterator]: {\n    value: function values() {\n      return this;\n    },\n  },\n});\n\n/**\n * Wrap the Array around the SafeIterator If Array.prototype [@@iterator] has been modified\n * @type {<T>(array: T[]) => Iterable<T>}\n */\nexport function safeIfNeeded(array) {\n  if (\n    array[SymbolIterator] === NativeArrayPrototypeSymbolIterator &&\n    ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext\n  ) {\n    return array;\n  }\n\n  const safe = ObjectCreate(SafeIteratorPrototype);\n  WeakMapPrototypeSet(arrayIterators, safe, ArrayPrototypeSymbolIterator(array));\n  return safe;\n}\n\n/** @type {WeakMap<{}, Generator<any>>} */\nconst generators = new NativeWeakMap();\n\n/** @see https://tc39.es/ecma262/#sec-%arrayiteratorprototype%-object */\nconst DummyArrayIteratorPrototype = ObjectCreate(IteratorPrototype, {\n  next: {\n    value: function next() {\n      const generator = WeakMapPrototypeGet(generators, this);\n      return GeneratorPrototypeNext(generator);\n    },\n    writable: true,\n    configurable: true,\n  },\n});\n\nfor (const key of ReflectOwnKeys(ArrayIteratorPrototype)) {\n  // next method has already defined\n  if (key === \"next\") {\n    continue;\n  }\n\n  // Copy ArrayIteratorPrototype descriptors to DummyArrayIteratorPrototype\n  ObjectDefineProperty(DummyArrayIteratorPrototype, key, ReflectGetOwnPropertyDescriptor(ArrayIteratorPrototype, key));\n}\n\n/**\n * Wrap the Generator around the dummy ArrayIterator\n * @type {<T>(generator: Generator<T>) => IterableIterator<T>}\n */\nexport function wrap(generator) {\n  const dummy = ObjectCreate(DummyArrayIteratorPrototype);\n  WeakMapPrototypeSet(generators, dummy, generator);\n  return dummy;\n}\n","import {\n  EPSILON,\n  MathAbs,\n  NativeArrayBuffer,\n  NativeFloat32Array,\n  NativeUint16Array,\n  NativeUint32Array,\n  NativeUint8Array,\n  NumberIsFinite,\n  NumberIsNaN,\n} from \"./primordials.mjs\";\n\nconst INVERSE_OF_EPSILON = 1 / EPSILON;\n\n/**\n * rounds to the nearest value;\n * if the number falls midway, it is rounded to the nearest value with an even least significant digit\n * @param {number} num\n * @returns {number}\n */\nfunction roundTiesToEven(num) {\n  return (num + INVERSE_OF_EPSILON) - INVERSE_OF_EPSILON;\n}\n\nconst FLOAT16_MIN_VALUE = 6.103515625e-05;\nconst FLOAT16_MAX_VALUE = 65504;\nconst FLOAT16_EPSILON = 0.0009765625;\n\nconst FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE = FLOAT16_EPSILON * FLOAT16_MIN_VALUE;\nconst FLOAT16_EPSILON_DEVIDED_BY_EPSILON = FLOAT16_EPSILON * INVERSE_OF_EPSILON;\n\n/**\n * round a number to a half float number\n * @param {unknown} num - double float\n * @returns {number} half float number bits\n */\nexport function roundToFloat16(num) {\n  const number = +num;\n\n  // NaN, Infinity, -Infinity, 0, -0\n  if (!NumberIsFinite(number) || number === 0) {\n    return number;\n  }\n\n  // finite except 0, -0\n  const sign = number > 0 ? 1 : -1;\n  const absolute = MathAbs(number);\n\n  // small number\n  if (absolute < FLOAT16_MIN_VALUE) {\n    return sign * roundTiesToEven(absolute / FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE) * FLOAT16_EPSILON_MULTIPLIED_BY_FLOAT16_MIN_VALUE;\n  }\n\n  const temp = (1 + FLOAT16_EPSILON_DEVIDED_BY_EPSILON) * absolute;\n  const result = temp - (temp - absolute);\n\n  // large number\n  if (result > FLOAT16_MAX_VALUE || NumberIsNaN(result)) {\n    return sign * Infinity;\n  }\n\n  return sign * result;\n}\n\n// base algorithm: http://fox-toolkit.org/ftp/fasthalffloatconversion.pdf\n\nconst buffer = new NativeArrayBuffer(4);\nconst floatView = new NativeFloat32Array(buffer);\nconst uint32View = new NativeUint32Array(buffer);\n\nconst baseTable = new NativeUint16Array(512);\nconst shiftTable = new NativeUint8Array(512);\n\nfor (let i = 0; i < 256; ++i) {\n  const e = i - 127;\n\n  // very small number (0, -0)\n  if (e < -27) {\n    baseTable[i]         = 0x0000;\n    baseTable[i | 0x100] = 0x8000;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // small number (denorm)\n  } else if (e < -14) {\n    baseTable[i]         =  0x0400 >> (-e - 14);\n    baseTable[i | 0x100] = (0x0400 >> (-e - 14)) | 0x8000;\n    shiftTable[i]         = -e - 1;\n    shiftTable[i | 0x100] = -e - 1;\n\n  // normal number\n  } else if (e <= 15) {\n    baseTable[i]         =  (e + 15) << 10;\n    baseTable[i | 0x100] = ((e + 15) << 10) | 0x8000;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n\n  // large number (Infinity, -Infinity)\n  } else if (e < 128) {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 24;\n    shiftTable[i | 0x100] = 24;\n\n  // stay (NaN, Infinity, -Infinity)\n  } else {\n    baseTable[i]         = 0x7c00;\n    baseTable[i | 0x100] = 0xfc00;\n    shiftTable[i]         = 13;\n    shiftTable[i | 0x100] = 13;\n  }\n}\n\n/**\n * round a number to a half float number bits\n * @param {unknown} num - double float\n * @returns {number} half float number bits\n */\nexport function roundToFloat16Bits(num) {\n  floatView[0] = roundToFloat16(num);\n  const f = uint32View[0];\n  const e = (f >> 23) & 0x1ff;\n  return baseTable[e] + ((f & 0x007fffff) >> shiftTable[e]);\n}\n\nconst mantissaTable = new NativeUint32Array(2048);\nfor (let i = 1; i < 1024; ++i) {\n  let m = i << 13; // zero pad mantissa bits\n  let e = 0; // zero exponent\n\n  // normalized\n  while ((m & 0x00800000) === 0) {\n    m <<= 1;\n    e -= 0x00800000; // decrement exponent\n  }\n\n  m &= ~0x00800000; // clear leading 1 bit\n  e += 0x38800000; // adjust bias\n\n  mantissaTable[i] = m | e;\n}\nfor (let i = 1024; i < 2048; ++i) {\n  mantissaTable[i] = 0x38000000 + ((i - 1024) << 13);\n}\n\nconst exponentTable = new NativeUint32Array(64);\nfor (let i = 1; i < 31; ++i) {\n  exponentTable[i] = i << 23;\n}\nexponentTable[31] = 0x47800000;\nexponentTable[32] = 0x80000000;\nfor (let i = 33; i < 63; ++i) {\n  exponentTable[i] = 0x80000000 + ((i - 32) << 23);\n}\nexponentTable[63] = 0xc7800000;\n\nconst offsetTable = new NativeUint16Array(64);\nfor (let i = 1; i < 64; ++i) {\n  if (i !== 32) {\n    offsetTable[i] = 1024;\n  }\n}\n\n/**\n * convert a half float number bits to a number\n * @param {number} float16bits - half float number bits\n * @returns {number} double float\n */\nexport function convertToNumber(float16bits) {\n  const i = float16bits >> 10;\n  uint32View[0] = mantissaTable[offsetTable[i] + (float16bits & 0x3ff)] + exponentTable[i];\n  return floatView[0];\n}\n","import { safeIfNeeded } from \"./_util/arrayIterator.mjs\";\nimport { convertToNumber, roundToFloat16Bits } from \"./_util/converter.mjs\";\nimport {\n  DataViewPrototypeGetUint16,\n  DataViewPrototypeSetUint16,\n} from \"./_util/primordials.mjs\";\n\n/**\n * returns an unsigned 16-bit float at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {[boolean]} opts\n * @returns {number}\n */\nexport function getFloat16(dataView, byteOffset, ...opts) {\n  return convertToNumber(\n    DataViewPrototypeGetUint16(dataView, byteOffset, ...safeIfNeeded(opts))\n  );\n}\n\n/**\n * stores an unsigned 16-bit float value at the specified byte offset from the start of the DataView\n * @param {DataView} dataView\n * @param {number} byteOffset\n * @param {number} value\n * @param {[boolean]} opts\n */\nexport function setFloat16(dataView, byteOffset, value, ...opts) {\n  return DataViewPrototypeSetUint16(\n    dataView,\n    byteOffset,\n    roundToFloat16Bits(value),\n    ...safeIfNeeded(opts)\n  );\n}\n","function getAttribute(tag, attributeName, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) console.log(\"[xml-utils] getting \" + attributeName + \" in \" + tag);\n\n  const xml = typeof tag === \"object\" ? tag.outer : tag;\n\n  // only search for attributes in the opening tag\n  const opening = xml.slice(0, xml.indexOf(\">\") + 1);\n\n  const quotechars = ['\"', \"'\"];\n  for (let i = 0; i < quotechars.length; i++) {\n    const char = quotechars[i];\n    const pattern = attributeName + \"\\\\=\" + char + \"([^\" + char + \"]*)\" + char;\n    if (debug) console.log(\"[xml-utils] pattern:\", pattern);\n\n    const re = new RegExp(pattern);\n    const match = re.exec(opening);\n    if (debug) console.log(\"[xml-utils] match:\", match);\n    if (match) return match[1];\n  }\n}\n\nmodule.exports = getAttribute;\nmodule.exports.default = getAttribute;\n","function indexOfMatch(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index;\n  else return -1;\n}\n\nmodule.exports = indexOfMatch;\nmodule.exports.default = indexOfMatch;\n","function indexOfMatchEnd(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index + match[0].length - 1;\n  else return -1;\n}\n\nmodule.exports = indexOfMatchEnd;\nmodule.exports.default = indexOfMatchEnd;\n","function countSubstring(string, substring) {\n  const pattern = new RegExp(substring, \"g\");\n  const match = string.match(pattern);\n  return match ? match.length : 0;\n}\n\nmodule.exports = countSubstring;\nmodule.exports.default = countSubstring;\n","const indexOfMatch = require(\"./index-of-match.js\");\nconst indexOfMatchEnd = require(\"./index-of-match-end.js\");\nconst countSubstring = require(\"./count-substring.js\");\n\nfunction findTagByName(xml, tagName, options) {\n  const debug = (options && options.debug) || false;\n  const nested = !(options && typeof options.nested === false);\n\n  const startIndex = (options && options.startIndex) || 0;\n\n  if (debug) console.log(\"[xml-utils] starting findTagByName with\", tagName, \" and \", options);\n\n  const start = indexOfMatch(xml, `\\<${tagName}[ \\n\\>\\/]`, startIndex);\n  if (debug) console.log(\"[xml-utils] start:\", start);\n  if (start === -1) return undefined;\n\n  const afterStart = xml.slice(start + tagName.length);\n\n  let relativeEnd = indexOfMatchEnd(afterStart, \"^[^<]*[ /]>\", 0);\n\n  const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === \"/\";\n  if (debug) console.log(\"[xml-utils] selfClosing:\", selfClosing);\n\n  if (selfClosing === false) {\n    // check if tag has subtags with the same name\n    if (nested) {\n      let startIndex = 0;\n      let openings = 1;\n      let closings = 0;\n      while ((relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", startIndex)) !== -1) {\n        const clip = afterStart.substring(startIndex, relativeEnd + 1);\n        openings += countSubstring(clip, \"<\" + tagName + \"[ \\n\\t>]\");\n        closings += countSubstring(clip, \"</\" + tagName + \">\");\n        // we can't have more openings than closings\n        if (closings >= openings) break;\n        startIndex = relativeEnd;\n      }\n    } else {\n      relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", 0);\n    }\n  }\n\n  const end = start + tagName.length + relativeEnd + 1;\n  if (debug) console.log(\"[xml-utils] end:\", end);\n  if (end === -1) return undefined;\n\n  const outer = xml.slice(start, end);\n  // tag is like <gml:identifier codeSpace=\"OGP\">urn:ogc:def:crs:EPSG::32617</gml:identifier>\n\n  let inner;\n  if (selfClosing) {\n    inner = null;\n  } else {\n    inner = outer.slice(outer.indexOf(\">\") + 1, outer.lastIndexOf(\"<\"));\n  }\n\n  return { inner, outer, start, end };\n}\n\nmodule.exports = findTagByName;\nmodule.exports.default = findTagByName;\n","const findTagByName = require(\"./find-tag-by-name.js\");\n\nfunction findTagsByName(xml, tagName, options) {\n  const tags = [];\n  const debug = (options && options.debug) || false;\n  const nested = options && typeof options.nested === \"boolean\" ? options.nested : true;\n  let startIndex = (options && options.startIndex) || 0;\n  let tag;\n  while ((tag = findTagByName(xml, tagName, { debug, startIndex }))) {\n    if (nested) {\n      startIndex = tag.start + 1 + tagName.length;\n    } else {\n      startIndex = tag.end;\n    }\n    tags.push(tag);\n  }\n  if (debug) console.log(\"findTagsByName found\", tags.length, \"tags\");\n  return tags;\n}\n\nmodule.exports = findTagsByName;\nmodule.exports.default = findTagsByName;\n","export const fieldTagNames = {\n  // TIFF Baseline\n  0x013B: 'Artist',\n  0x0102: 'BitsPerSample',\n  0x0109: 'CellLength',\n  0x0108: 'CellWidth',\n  0x0140: 'ColorMap',\n  0x0103: 'Compression',\n  0x8298: 'Copyright',\n  0x0132: 'DateTime',\n  0x0152: 'ExtraSamples',\n  0x010A: 'FillOrder',\n  0x0121: 'FreeByteCounts',\n  0x0120: 'FreeOffsets',\n  0x0123: 'GrayResponseCurve',\n  0x0122: 'GrayResponseUnit',\n  0x013C: 'HostComputer',\n  0x010E: 'ImageDescription',\n  0x0101: 'ImageLength',\n  0x0100: 'ImageWidth',\n  0x010F: 'Make',\n  0x0119: 'MaxSampleValue',\n  0x0118: 'MinSampleValue',\n  0x0110: 'Model',\n  0x00FE: 'NewSubfileType',\n  0x0112: 'Orientation',\n  0x0106: 'PhotometricInterpretation',\n  0x011C: 'PlanarConfiguration',\n  0x0128: 'ResolutionUnit',\n  0x0116: 'RowsPerStrip',\n  0x0115: 'SamplesPerPixel',\n  0x0131: 'Software',\n  0x0117: 'StripByteCounts',\n  0x0111: 'StripOffsets',\n  0x00FF: 'SubfileType',\n  0x0107: 'Threshholding',\n  0x011A: 'XResolution',\n  0x011B: 'YResolution',\n\n  // TIFF Extended\n  0x0146: 'BadFaxLines',\n  0x0147: 'CleanFaxData',\n  0x0157: 'ClipPath',\n  0x0148: 'ConsecutiveBadFaxLines',\n  0x01B1: 'Decode',\n  0x01B2: 'DefaultImageColor',\n  0x010D: 'DocumentName',\n  0x0150: 'DotRange',\n  0x0141: 'HalftoneHints',\n  0x015A: 'Indexed',\n  0x015B: 'JPEGTables',\n  0x011D: 'PageName',\n  0x0129: 'PageNumber',\n  0x013D: 'Predictor',\n  0x013F: 'PrimaryChromaticities',\n  0x0214: 'ReferenceBlackWhite',\n  0x0153: 'SampleFormat',\n  0x0154: 'SMinSampleValue',\n  0x0155: 'SMaxSampleValue',\n  0x022F: 'StripRowCounts',\n  0x014A: 'SubIFDs',\n  0x0124: 'T4Options',\n  0x0125: 'T6Options',\n  0x0145: 'TileByteCounts',\n  0x0143: 'TileLength',\n  0x0144: 'TileOffsets',\n  0x0142: 'TileWidth',\n  0x012D: 'TransferFunction',\n  0x013E: 'WhitePoint',\n  0x0158: 'XClipPathUnits',\n  0x011E: 'XPosition',\n  0x0211: 'YCbCrCoefficients',\n  0x0213: 'YCbCrPositioning',\n  0x0212: 'YCbCrSubSampling',\n  0x0159: 'YClipPathUnits',\n  0x011F: 'YPosition',\n\n  // EXIF\n  0x9202: 'ApertureValue',\n  0xA001: 'ColorSpace',\n  0x9004: 'DateTimeDigitized',\n  0x9003: 'DateTimeOriginal',\n  0x8769: 'Exif IFD',\n  0x9000: 'ExifVersion',\n  0x829A: 'ExposureTime',\n  0xA300: 'FileSource',\n  0x9209: 'Flash',\n  0xA000: 'FlashpixVersion',\n  0x829D: 'FNumber',\n  0xA420: 'ImageUniqueID',\n  0x9208: 'LightSource',\n  0x927C: 'MakerNote',\n  0x9201: 'ShutterSpeedValue',\n  0x9286: 'UserComment',\n\n  // IPTC\n  0x83BB: 'IPTC',\n\n  // ICC\n  0x8773: 'ICC Profile',\n\n  // XMP\n  0x02BC: 'XMP',\n\n  // GDAL\n  0xA480: 'GDAL_METADATA',\n  0xA481: 'GDAL_NODATA',\n\n  // Photoshop\n  0x8649: 'Photoshop',\n\n  // GeoTiff\n  0x830E: 'ModelPixelScale',\n  0x8482: 'ModelTiepoint',\n  0x85D8: 'ModelTransformation',\n  0x87AF: 'GeoKeyDirectory',\n  0x87B0: 'GeoDoubleParams',\n  0x87B1: 'GeoAsciiParams',\n\n  // LERC\n  0xC5F2: 'LercParameters',\n};\n\nexport const fieldTags = {};\nfor (const key in fieldTagNames) {\n  if (fieldTagNames.hasOwnProperty(key)) {\n    fieldTags[fieldTagNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const fieldTagTypes = {\n  256: 'SHORT',\n  257: 'SHORT',\n  258: 'SHORT',\n  259: 'SHORT',\n  262: 'SHORT',\n  273: 'LONG',\n  274: 'SHORT',\n  277: 'SHORT',\n  278: 'LONG',\n  279: 'LONG',\n  282: 'RATIONAL',\n  283: 'RATIONAL',\n  284: 'SHORT',\n  286: 'SHORT',\n  287: 'RATIONAL',\n  296: 'SHORT',\n  297: 'SHORT',\n  305: 'ASCII',\n  306: 'ASCII',\n  338: 'SHORT',\n  339: 'SHORT',\n  513: 'LONG',\n  514: 'LONG',\n  1024: 'SHORT',\n  1025: 'SHORT',\n  2048: 'SHORT',\n  2049: 'ASCII',\n  3072: 'SHORT',\n  3073: 'ASCII',\n  33550: 'DOUBLE',\n  33922: 'DOUBLE',\n  34264: 'DOUBLE',\n  34665: 'LONG',\n  34735: 'SHORT',\n  34736: 'DOUBLE',\n  34737: 'ASCII',\n  42113: 'ASCII',\n};\n\nexport const arrayFields = [\n  fieldTags.BitsPerSample,\n  fieldTags.ExtraSamples,\n  fieldTags.SampleFormat,\n  fieldTags.StripByteCounts,\n  fieldTags.StripOffsets,\n  fieldTags.StripRowCounts,\n  fieldTags.TileByteCounts,\n  fieldTags.TileOffsets,\n  fieldTags.SubIFDs,\n];\n\nexport const fieldTypeNames = {\n  0x0001: 'BYTE',\n  0x0002: 'ASCII',\n  0x0003: 'SHORT',\n  0x0004: 'LONG',\n  0x0005: 'RATIONAL',\n  0x0006: 'SBYTE',\n  0x0007: 'UNDEFINED',\n  0x0008: 'SSHORT',\n  0x0009: 'SLONG',\n  0x000A: 'SRATIONAL',\n  0x000B: 'FLOAT',\n  0x000C: 'DOUBLE',\n  // IFD offset, suggested by https://owl.phy.queensu.ca/~phil/exiftool/standards.html\n  0x000D: 'IFD',\n  // introduced by BigTIFF\n  0x0010: 'LONG8',\n  0x0011: 'SLONG8',\n  0x0012: 'IFD8',\n};\n\nexport const fieldTypes = {};\nfor (const key in fieldTypeNames) {\n  if (fieldTypeNames.hasOwnProperty(key)) {\n    fieldTypes[fieldTypeNames[key]] = parseInt(key, 10);\n  }\n}\n\nexport const photometricInterpretations = {\n  WhiteIsZero: 0,\n  BlackIsZero: 1,\n  RGB: 2,\n  Palette: 3,\n  TransparencyMask: 4,\n  CMYK: 5,\n  YCbCr: 6,\n\n  CIELab: 8,\n  ICCLab: 9,\n};\n\nexport const ExtraSamplesValues = {\n  Unspecified: 0,\n  Assocalpha: 1,\n  Unassalpha: 2,\n};\n\nexport const LercParameters = {\n  Version: 0,\n  AddCompression: 1,\n};\n\nexport const LercAddCompression = {\n  None: 0,\n  Deflate: 1,\n  Zstandard: 2,\n};\n\nexport const geoKeyNames = {\n  1024: 'GTModelTypeGeoKey',\n  1025: 'GTRasterTypeGeoKey',\n  1026: 'GTCitationGeoKey',\n  2048: 'GeographicTypeGeoKey',\n  2049: 'GeogCitationGeoKey',\n  2050: 'GeogGeodeticDatumGeoKey',\n  2051: 'GeogPrimeMeridianGeoKey',\n  2052: 'GeogLinearUnitsGeoKey',\n  2053: 'GeogLinearUnitSizeGeoKey',\n  2054: 'GeogAngularUnitsGeoKey',\n  2055: 'GeogAngularUnitSizeGeoKey',\n  2056: 'GeogEllipsoidGeoKey',\n  2057: 'GeogSemiMajorAxisGeoKey',\n  2058: 'GeogSemiMinorAxisGeoKey',\n  2059: 'GeogInvFlatteningGeoKey',\n  2060: 'GeogAzimuthUnitsGeoKey',\n  2061: 'GeogPrimeMeridianLongGeoKey',\n  2062: 'GeogTOWGS84GeoKey',\n  3072: 'ProjectedCSTypeGeoKey',\n  3073: 'PCSCitationGeoKey',\n  3074: 'ProjectionGeoKey',\n  3075: 'ProjCoordTransGeoKey',\n  3076: 'ProjLinearUnitsGeoKey',\n  3077: 'ProjLinearUnitSizeGeoKey',\n  3078: 'ProjStdParallel1GeoKey',\n  3079: 'ProjStdParallel2GeoKey',\n  3080: 'ProjNatOriginLongGeoKey',\n  3081: 'ProjNatOriginLatGeoKey',\n  3082: 'ProjFalseEastingGeoKey',\n  3083: 'ProjFalseNorthingGeoKey',\n  3084: 'ProjFalseOriginLongGeoKey',\n  3085: 'ProjFalseOriginLatGeoKey',\n  3086: 'ProjFalseOriginEastingGeoKey',\n  3087: 'ProjFalseOriginNorthingGeoKey',\n  3088: 'ProjCenterLongGeoKey',\n  3089: 'ProjCenterLatGeoKey',\n  3090: 'ProjCenterEastingGeoKey',\n  3091: 'ProjCenterNorthingGeoKey',\n  3092: 'ProjScaleAtNatOriginGeoKey',\n  3093: 'ProjScaleAtCenterGeoKey',\n  3094: 'ProjAzimuthAngleGeoKey',\n  3095: 'ProjStraightVertPoleLongGeoKey',\n  3096: 'ProjRectifiedGridAngleGeoKey',\n  4096: 'VerticalCSTypeGeoKey',\n  4097: 'VerticalCitationGeoKey',\n  4098: 'VerticalDatumGeoKey',\n  4099: 'VerticalUnitsGeoKey',\n};\n\nexport const geoKeys = {};\nfor (const key in geoKeyNames) {\n  if (geoKeyNames.hasOwnProperty(key)) {\n    geoKeys[geoKeyNames[key]] = parseInt(key, 10);\n  }\n}\n","export function fromWhiteIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = 256 - (raster[i] / max * 256);\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromBlackIsZero(raster, max) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  let value;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    value = raster[i] / max * 256;\n    rgbRaster[j] = value;\n    rgbRaster[j + 1] = value;\n    rgbRaster[j + 2] = value;\n  }\n  return rgbRaster;\n}\n\nexport function fromPalette(raster, colorMap) {\n  const { width, height } = raster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  const greenOffset = colorMap.length / 3;\n  const blueOffset = colorMap.length / 3 * 2;\n  for (let i = 0, j = 0; i < raster.length; ++i, j += 3) {\n    const mapIndex = raster[i];\n    rgbRaster[j] = colorMap[mapIndex] / 65536 * 256;\n    rgbRaster[j + 1] = colorMap[mapIndex + greenOffset] / 65536 * 256;\n    rgbRaster[j + 2] = colorMap[mapIndex + blueOffset] / 65536 * 256;\n  }\n  return rgbRaster;\n}\n\nexport function fromCMYK(cmykRaster) {\n  const { width, height } = cmykRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n  for (let i = 0, j = 0; i < cmykRaster.length; i += 4, j += 3) {\n    const c = cmykRaster[i];\n    const m = cmykRaster[i + 1];\n    const y = cmykRaster[i + 2];\n    const k = cmykRaster[i + 3];\n\n    rgbRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n    rgbRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n  }\n  return rgbRaster;\n}\n\nexport function fromYCbCr(yCbCrRaster) {\n  const { width, height } = yCbCrRaster;\n  const rgbRaster = new Uint8ClampedArray(width * height * 3);\n  for (let i = 0, j = 0; i < yCbCrRaster.length; i += 3, j += 3) {\n    const y = yCbCrRaster[i];\n    const cb = yCbCrRaster[i + 1];\n    const cr = yCbCrRaster[i + 2];\n\n    rgbRaster[j] = (y + (1.40200 * (cr - 0x80)));\n    rgbRaster[j + 1] = (y - (0.34414 * (cb - 0x80)) - (0.71414 * (cr - 0x80)));\n    rgbRaster[j + 2] = (y + (1.77200 * (cb - 0x80)));\n  }\n  return rgbRaster;\n}\n\nconst Xn = 0.95047;\nconst Yn = 1.00000;\nconst Zn = 1.08883;\n\n// from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n\nexport function fromCIELab(cieLabRaster) {\n  const { width, height } = cieLabRaster;\n  const rgbRaster = new Uint8Array(width * height * 3);\n\n  for (let i = 0, j = 0; i < cieLabRaster.length; i += 3, j += 3) {\n    const L = cieLabRaster[i + 0];\n    const a_ = cieLabRaster[i + 1] << 24 >> 24; // conversion from uint8 to int8\n    const b_ = cieLabRaster[i + 2] << 24 >> 24; // same\n\n    let y = (L + 16) / 116;\n    let x = (a_ / 500) + y;\n    let z = y - (b_ / 200);\n    let r;\n    let g;\n    let b;\n\n    x = Xn * ((x * x * x > 0.008856) ? x * x * x : (x - (16 / 116)) / 7.787);\n    y = Yn * ((y * y * y > 0.008856) ? y * y * y : (y - (16 / 116)) / 7.787);\n    z = Zn * ((z * z * z > 0.008856) ? z * z * z : (z - (16 / 116)) / 7.787);\n\n    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);\n    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);\n    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);\n\n    r = (r > 0.0031308) ? ((1.055 * (r ** (1 / 2.4))) - 0.055) : 12.92 * r;\n    g = (g > 0.0031308) ? ((1.055 * (g ** (1 / 2.4))) - 0.055) : 12.92 * g;\n    b = (b > 0.0031308) ? ((1.055 * (b ** (1 / 2.4))) - 0.055) : 12.92 * b;\n\n    rgbRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n    rgbRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n    rgbRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n  }\n  return rgbRaster;\n}\n","const registry = new Map();\n\nexport function addDecoder(cases, importFn) {\n  if (!Array.isArray(cases)) {\n    cases = [cases]; // eslint-disable-line no-param-reassign\n  }\n  cases.forEach((c) => registry.set(c, importFn));\n}\n\nexport async function getDecoder(fileDirectory) {\n  const importFn = registry.get(fileDirectory.Compression);\n  if (!importFn) {\n    throw new Error(`Unknown compression method identifier: ${fileDirectory.Compression}`);\n  }\n  const Decoder = await importFn();\n  return new Decoder(fileDirectory);\n}\n\n// Add default decoders to registry (end-user may override with other implementations)\naddDecoder([undefined, 1], () => import('./raw.js').then((m) => m.default));\naddDecoder(5, () => import('./lzw.js').then((m) => m.default));\naddDecoder(6, () => {\n  throw new Error('old style JPEG compression is not supported.');\n});\naddDecoder(7, () => import('./jpeg.js').then((m) => m.default));\naddDecoder([8, 32946], () => import('./deflate.js').then((m) => m.default));\naddDecoder(32773, () => import('./packbits.js').then((m) => m.default));\naddDecoder(34887, () => import('./lerc.js')\n  .then(async (m) => {\n    await m.zstd.init();\n    return m;\n  })\n  .then((m) => m.default),\n);\naddDecoder(50001, () => import('./webimage.js').then((m) => m.default));\n","/**\n * @module resample\n */\n\nfunction copyNewSize(array, width, height, samplesPerPixel = 1) {\n  return new (Object.getPrototypeOf(array).constructor)(width * height * samplesPerPixel);\n}\n\n/**\n * Resample the input arrays using nearest neighbor value selection.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const cy = Math.min(Math.round(relY * y), inHeight - 1);\n      for (let x = 0; x < outWidth; ++x) {\n        const cx = Math.min(Math.round(relX * x), inWidth - 1);\n        const value = array[(cy * inWidth) + cx];\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n// simple linear interpolation, code from:\n// https://en.wikipedia.org/wiki/Linear_interpolation#Programming_language_support\nfunction lerp(v0, v1, t) {\n  return ((1 - t) * v0) + (t * v1);\n}\n\n/**\n * Resample the input arrays using bilinear interpolation.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  return valueArrays.map((array) => {\n    const newArray = copyNewSize(array, outWidth, outHeight);\n    for (let y = 0; y < outHeight; ++y) {\n      const rawY = relY * y;\n\n      const yl = Math.floor(rawY);\n      const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n      for (let x = 0; x < outWidth; ++x) {\n        const rawX = relX * x;\n        const tx = rawX % 1;\n\n        const xl = Math.floor(rawX);\n        const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n        const ll = array[(yl * inWidth) + xl];\n        const hl = array[(yl * inWidth) + xh];\n        const lh = array[(yh * inWidth) + xl];\n        const hh = array[(yh * inWidth) + xh];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth) + x] = value;\n      }\n    }\n    return newArray;\n  });\n}\n\n/**\n * Resample the input arrays using the selected resampling method.\n * @param {TypedArray[]} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray[]} The resampled rasters\n */\nexport function resample(valueArrays, inWidth, inHeight, outWidth, outHeight, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearest(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinear(valueArrays, inWidth, inHeight, outWidth, outHeight);\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n\n/**\n * Resample the pixel interleaved input array using nearest neighbor value selection.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleNearestInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const cy = Math.min(Math.round(relY * y), inHeight - 1);\n    for (let x = 0; x < outWidth; ++x) {\n      const cx = Math.min(Math.round(relX * x), inWidth - 1);\n      for (let i = 0; i < samples; ++i) {\n        const value = valueArray[(cy * inWidth * samples) + (cx * samples) + i];\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using bilinear interpolation.\n * @param {TypedArray} valueArrays The input arrays to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                         interleaved data\n * @returns {TypedArray} The resampled raster\n */\nexport function resampleBilinearInterleaved(\n  valueArray, inWidth, inHeight, outWidth, outHeight, samples) {\n  const relX = inWidth / outWidth;\n  const relY = inHeight / outHeight;\n  const newArray = copyNewSize(valueArray, outWidth, outHeight, samples);\n  for (let y = 0; y < outHeight; ++y) {\n    const rawY = relY * y;\n\n    const yl = Math.floor(rawY);\n    const yh = Math.min(Math.ceil(rawY), (inHeight - 1));\n\n    for (let x = 0; x < outWidth; ++x) {\n      const rawX = relX * x;\n      const tx = rawX % 1;\n\n      const xl = Math.floor(rawX);\n      const xh = Math.min(Math.ceil(rawX), (inWidth - 1));\n\n      for (let i = 0; i < samples; ++i) {\n        const ll = valueArray[(yl * inWidth * samples) + (xl * samples) + i];\n        const hl = valueArray[(yl * inWidth * samples) + (xh * samples) + i];\n        const lh = valueArray[(yh * inWidth * samples) + (xl * samples) + i];\n        const hh = valueArray[(yh * inWidth * samples) + (xh * samples) + i];\n\n        const value = lerp(\n          lerp(ll, hl, tx),\n          lerp(lh, hh, tx),\n          rawY % 1,\n        );\n        newArray[(y * outWidth * samples) + (x * samples) + i] = value;\n      }\n    }\n  }\n  return newArray;\n}\n\n/**\n * Resample the pixel interleaved input array using the selected resampling method.\n * @param {TypedArray} valueArray The input array to resample\n * @param {number} inWidth The width of the input rasters\n * @param {number} inHeight The height of the input rasters\n * @param {number} outWidth The desired width of the output rasters\n * @param {number} outHeight The desired height of the output rasters\n * @param {number} samples The number of samples per pixel for pixel\n *                                 interleaved data\n * @param {string} [method = 'nearest'] The desired resampling method\n * @returns {TypedArray} The resampled rasters\n */\nexport function resampleInterleaved(valueArray, inWidth, inHeight, outWidth, outHeight, samples, method = 'nearest') {\n  switch (method.toLowerCase()) {\n    case 'nearest':\n      return resampleNearestInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    case 'bilinear':\n    case 'linear':\n      return resampleBilinearInterleaved(\n        valueArray, inWidth, inHeight, outWidth, outHeight, samples,\n      );\n    default:\n      throw new Error(`Unsupported resampling method: '${method}'`);\n  }\n}\n","/** @module geotiffimage */\nimport { getFloat16 } from '@petamoriken/float16';\nimport getAttribute from 'xml-utils/get-attribute.js';\nimport findTagsByName from 'xml-utils/find-tags-by-name.js';\n\nimport { photometricInterpretations, ExtraSamplesValues } from './globals.js';\nimport { fromWhiteIsZero, fromBlackIsZero, fromPalette, fromCMYK, fromYCbCr, fromCIELab } from './rgb.js';\nimport { getDecoder } from './compression/index.js';\nimport { resample, resampleInterleaved } from './resample.js';\n\n/**\n * @typedef {Object} ReadRasterOptions\n * @property {Array<number>} [window=whole window] the subset to read data from in pixels.\n * @property {Array<number>} [bbox=whole image] the subset to read data from in\n *                                           geographical coordinates.\n * @property {Array<number>} [samples=all samples] the selection of samples to read from. Default is all samples.\n * @property {boolean} [interleave=false] whether the data shall be read\n *                                             in one single array or separate\n *                                             arrays.\n * @property {Pool} [pool=null] The optional decoder pool to use.\n * @property {number} [width] The desired width of the output. When the width is not the\n *                                 same as the images, resampling will be performed.\n * @property {number} [height] The desired height of the output. When the width is not the\n *                                  same as the images, resampling will be performed.\n * @property {string} [resampleMethod='nearest'] The desired resampling method.\n * @property {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                                       to be aborted\n * @property {number|number[]} [fillValue] The value to use for parts of the image\n *                                              outside of the images extent. When multiple\n *                                              samples are requested, an array of fill values\n *                                              can be passed.\n */\n\n/** @typedef {import(\"./geotiff.js\").TypedArray} TypedArray */\n/** @typedef {import(\"./geotiff.js\").ReadRasterResult} ReadRasterResult */\n\nfunction sum(array, start, end) {\n  let s = 0;\n  for (let i = start; i < end; ++i) {\n    s += array[i];\n  }\n  return s;\n}\n\nfunction arrayForType(format, bitsPerSample, size) {\n  switch (format) {\n    case 1: // unsigned integer data\n      if (bitsPerSample <= 8) {\n        return new Uint8Array(size);\n      } else if (bitsPerSample <= 16) {\n        return new Uint16Array(size);\n      } else if (bitsPerSample <= 32) {\n        return new Uint32Array(size);\n      }\n      break;\n    case 2: // twos complement signed integer data\n      if (bitsPerSample === 8) {\n        return new Int8Array(size);\n      } else if (bitsPerSample === 16) {\n        return new Int16Array(size);\n      } else if (bitsPerSample === 32) {\n        return new Int32Array(size);\n      }\n      break;\n    case 3: // floating point data\n      switch (bitsPerSample) {\n        case 16:\n        case 32:\n          return new Float32Array(size);\n        case 64:\n          return new Float64Array(size);\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n  throw Error('Unsupported data format/bitsPerSample');\n}\n\nfunction needsNormalization(format, bitsPerSample) {\n  if ((format === 1 || format === 2) && bitsPerSample <= 32 && bitsPerSample % 8 === 0) {\n    return false;\n  } else if (format === 3 && (bitsPerSample === 16 || bitsPerSample === 32 || bitsPerSample === 64)) {\n    return false;\n  }\n  return true;\n}\n\nfunction normalizeArray(inBuffer, format, planarConfiguration, samplesPerPixel, bitsPerSample, tileWidth, tileHeight) {\n  // const inByteArray = new Uint8Array(inBuffer);\n  const view = new DataView(inBuffer);\n  const outSize = planarConfiguration === 2\n    ? tileHeight * tileWidth\n    : tileHeight * tileWidth * samplesPerPixel;\n  const samplesToTransfer = planarConfiguration === 2\n    ? 1 : samplesPerPixel;\n  const outArray = arrayForType(format, bitsPerSample, outSize);\n  // let pixel = 0;\n\n  const bitMask = parseInt('1'.repeat(bitsPerSample), 2);\n\n  if (format === 1) { // unsigned integer\n    // translation of https://github.com/OSGeo/gdal/blob/master/gdal/frmts/gtiff/geotiff.cpp#L7337\n    let pixelBitSkip;\n    // let sampleBitOffset = 0;\n    if (planarConfiguration === 1) {\n      pixelBitSkip = samplesPerPixel * bitsPerSample;\n      // sampleBitOffset = (samplesPerPixel - 1) * bitsPerSample;\n    } else {\n      pixelBitSkip = bitsPerSample;\n    }\n\n    // Bits per line rounds up to next byte boundary.\n    let bitsPerLine = tileWidth * pixelBitSkip;\n    if ((bitsPerLine & 7) !== 0) {\n      bitsPerLine = (bitsPerLine + 7) & (~7);\n    }\n\n    for (let y = 0; y < tileHeight; ++y) {\n      const lineBitOffset = y * bitsPerLine;\n      for (let x = 0; x < tileWidth; ++x) {\n        const pixelBitOffset = lineBitOffset + (x * samplesToTransfer * bitsPerSample);\n        for (let i = 0; i < samplesToTransfer; ++i) {\n          const bitOffset = pixelBitOffset + (i * bitsPerSample);\n          const outIndex = (((y * tileWidth) + x) * samplesToTransfer) + i;\n\n          const byteOffset = Math.floor(bitOffset / 8);\n          const innerBitOffset = bitOffset % 8;\n          if (innerBitOffset + bitsPerSample <= 8) {\n            outArray[outIndex] = (view.getUint8(byteOffset) >> (8 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 16) {\n            outArray[outIndex] = (view.getUint16(byteOffset) >> (16 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else if (innerBitOffset + bitsPerSample <= 24) {\n            const raw = (view.getUint16(byteOffset) << 8) | (view.getUint8(byteOffset + 2));\n            outArray[outIndex] = (raw >> (24 - bitsPerSample) - innerBitOffset) & bitMask;\n          } else {\n            outArray[outIndex] = (view.getUint32(byteOffset) >> (32 - bitsPerSample) - innerBitOffset) & bitMask;\n          }\n\n          // let outWord = 0;\n          // for (let bit = 0; bit < bitsPerSample; ++bit) {\n          //   if (inByteArray[bitOffset >> 3]\n          //     & (0x80 >> (bitOffset & 7))) {\n          //     outWord |= (1 << (bitsPerSample - 1 - bit));\n          //   }\n          //   ++bitOffset;\n          // }\n\n          // outArray[outIndex] = outWord;\n          // outArray[pixel] = outWord;\n          // pixel += 1;\n        }\n        // bitOffset = bitOffset + pixelBitSkip - bitsPerSample;\n      }\n    }\n  } else if (format === 3) { // floating point\n    // Float16 is handled elsewhere\n    // normalize 16/24 bit floats to 32 bit floats in the array\n    // console.time();\n    // if (bitsPerSample === 16) {\n    //   for (let byte = 0, outIndex = 0; byte < inBuffer.byteLength; byte += 2, ++outIndex) {\n    //     outArray[outIndex] = getFloat16(view, byte);\n    //   }\n    // }\n    // console.timeEnd()\n  }\n\n  return outArray.buffer;\n}\n\n/**\n * GeoTIFF sub-file image.\n */\nclass GeoTIFFImage {\n  /**\n   * @constructor\n   * @param {Object} fileDirectory The parsed file directory\n   * @param {Object} geoKeys The parsed geo-keys\n   * @param {DataView} dataView The DataView for the underlying file.\n   * @param {Boolean} littleEndian Whether the file is encoded in little or big endian\n   * @param {Boolean} cache Whether or not decoded tiles shall be cached\n   * @param {import('./source/basesource').BaseSource} source The datasource to read from\n   */\n  constructor(fileDirectory, geoKeys, dataView, littleEndian, cache, source) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeys = geoKeys;\n    this.dataView = dataView;\n    this.littleEndian = littleEndian;\n    this.tiles = cache ? {} : null;\n    this.isTiled = !fileDirectory.StripOffsets;\n    const planarConfiguration = fileDirectory.PlanarConfiguration;\n    this.planarConfiguration = (typeof planarConfiguration === 'undefined') ? 1 : planarConfiguration;\n    if (this.planarConfiguration !== 1 && this.planarConfiguration !== 2) {\n      throw new Error('Invalid planar configuration.');\n    }\n\n    this.source = source;\n  }\n\n  /**\n   * Returns the associated parsed file directory.\n   * @returns {Object} the parsed file directory\n   */\n  getFileDirectory() {\n    return this.fileDirectory;\n  }\n\n  /**\n   * Returns the associated parsed geo keys.\n   * @returns {Object} the parsed geo keys\n   */\n  getGeoKeys() {\n    return this.geoKeys;\n  }\n\n  /**\n   * Returns the width of the image.\n   * @returns {Number} the width of the image\n   */\n  getWidth() {\n    return this.fileDirectory.ImageWidth;\n  }\n\n  /**\n   * Returns the height of the image.\n   * @returns {Number} the height of the image\n   */\n  getHeight() {\n    return this.fileDirectory.ImageLength;\n  }\n\n  /**\n   * Returns the number of samples per pixel.\n   * @returns {Number} the number of samples per pixel\n   */\n  getSamplesPerPixel() {\n    return typeof this.fileDirectory.SamplesPerPixel !== 'undefined'\n      ? this.fileDirectory.SamplesPerPixel : 1;\n  }\n\n  /**\n   * Returns the width of each tile.\n   * @returns {Number} the width of each tile\n   */\n  getTileWidth() {\n    return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth();\n  }\n\n  /**\n   * Returns the height of each tile.\n   * @returns {Number} the height of each tile\n   */\n  getTileHeight() {\n    if (this.isTiled) {\n      return this.fileDirectory.TileLength;\n    }\n    if (typeof this.fileDirectory.RowsPerStrip !== 'undefined') {\n      return Math.min(this.fileDirectory.RowsPerStrip, this.getHeight());\n    }\n    return this.getHeight();\n  }\n\n  getBlockWidth() {\n    return this.getTileWidth();\n  }\n\n  getBlockHeight(y) {\n    if (this.isTiled || (y + 1) * this.getTileHeight() <= this.getHeight()) {\n      return this.getTileHeight();\n    } else {\n      return this.getHeight() - (y * this.getTileHeight());\n    }\n  }\n\n  /**\n   * Calculates the number of bytes for each pixel across all samples. Only full\n   * bytes are supported, an exception is thrown when this is not the case.\n   * @returns {Number} the bytes per pixel\n   */\n  getBytesPerPixel() {\n    let bytes = 0;\n    for (let i = 0; i < this.fileDirectory.BitsPerSample.length; ++i) {\n      bytes += this.getSampleByteSize(i);\n    }\n    return bytes;\n  }\n\n  getSampleByteSize(i) {\n    if (i >= this.fileDirectory.BitsPerSample.length) {\n      throw new RangeError(`Sample index ${i} is out of range.`);\n    }\n    return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8);\n  }\n\n  getReaderForSample(sampleIndex) {\n    const format = this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n    const bitsPerSample = this.fileDirectory.BitsPerSample[sampleIndex];\n    switch (format) {\n      case 1: // unsigned integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getUint8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getUint16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getUint32;\n        }\n        break;\n      case 2: // twos complement signed integer data\n        if (bitsPerSample <= 8) {\n          return DataView.prototype.getInt8;\n        } else if (bitsPerSample <= 16) {\n          return DataView.prototype.getInt16;\n        } else if (bitsPerSample <= 32) {\n          return DataView.prototype.getInt32;\n        }\n        break;\n      case 3:\n        switch (bitsPerSample) {\n          case 16:\n            return function (offset, littleEndian) {\n              return getFloat16(this, offset, littleEndian);\n            };\n          case 32:\n            return DataView.prototype.getFloat32;\n          case 64:\n            return DataView.prototype.getFloat64;\n          default:\n            break;\n        }\n        break;\n      default:\n        break;\n    }\n    throw Error('Unsupported data format/bitsPerSample');\n  }\n\n  getSampleFormat(sampleIndex = 0) {\n    return this.fileDirectory.SampleFormat\n      ? this.fileDirectory.SampleFormat[sampleIndex] : 1;\n  }\n\n  getBitsPerSample(sampleIndex = 0) {\n    return this.fileDirectory.BitsPerSample[sampleIndex];\n  }\n\n  getArrayForSample(sampleIndex, size) {\n    const format = this.getSampleFormat(sampleIndex);\n    const bitsPerSample = this.getBitsPerSample(sampleIndex);\n    return arrayForType(format, bitsPerSample, size);\n  }\n\n  /**\n   * Returns the decoded strip or tile.\n   * @param {Number} x the strip or tile x-offset\n   * @param {Number} y the tile y-offset (0 for stripped images)\n   * @param {Number} sample the sample to get for separated samples\n   * @param {import(\"./geotiff\").Pool|import(\"./geotiff\").BaseDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise.<ArrayBuffer>}\n   */\n  async getTileOrStrip(x, y, sample, poolOrDecoder, signal) {\n    const numTilesPerRow = Math.ceil(this.getWidth() / this.getTileWidth());\n    const numTilesPerCol = Math.ceil(this.getHeight() / this.getTileHeight());\n    let index;\n    const { tiles } = this;\n    if (this.planarConfiguration === 1) {\n      index = (y * numTilesPerRow) + x;\n    } else if (this.planarConfiguration === 2) {\n      index = (sample * numTilesPerRow * numTilesPerCol) + (y * numTilesPerRow) + x;\n    }\n\n    let offset;\n    let byteCount;\n    if (this.isTiled) {\n      offset = this.fileDirectory.TileOffsets[index];\n      byteCount = this.fileDirectory.TileByteCounts[index];\n    } else {\n      offset = this.fileDirectory.StripOffsets[index];\n      byteCount = this.fileDirectory.StripByteCounts[index];\n    }\n    const slice = (await this.source.fetch([{ offset, length: byteCount }], signal))[0];\n\n    let request;\n    if (tiles === null || !tiles[index]) {\n    // resolve each request by potentially applying array normalization\n      request = (async () => {\n        let data = await poolOrDecoder.decode(this.fileDirectory, slice);\n        const sampleFormat = this.getSampleFormat();\n        const bitsPerSample = this.getBitsPerSample();\n        if (needsNormalization(sampleFormat, bitsPerSample)) {\n          data = normalizeArray(\n            data,\n            sampleFormat,\n            this.planarConfiguration,\n            this.getSamplesPerPixel(),\n            bitsPerSample,\n            this.getTileWidth(),\n            this.getBlockHeight(y),\n          );\n        }\n        return data;\n      })();\n\n      // set the cache\n      if (tiles !== null) {\n        tiles[index] = request;\n      }\n    } else {\n      // get from the cache\n      request = tiles[index];\n    }\n\n    // cache the tile request\n    return { x, y, sample, data: await request };\n  }\n\n  /**\n   * Internal read function.\n   * @private\n   * @param {Array} imageWindow The image window in pixel coordinates\n   * @param {Array} samples The selected samples (0-based indices)\n   * @param {TypedArray|TypedArray[]} valueArrays The array(s) to write into\n   * @param {Boolean} interleave Whether or not to write in an interleaved manner\n   * @param {import(\"./geotiff\").Pool|AbstractDecoder} poolOrDecoder the decoder or decoder pool\n   * @param {number} width the width of window to be read into\n   * @param {number} height the height of window to be read into\n   * @param {number} resampleMethod the resampling method to be used when interpolating\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   * @returns {Promise<ReadRasterResult>}\n   */\n  async _readRaster(imageWindow, samples, valueArrays, interleave, poolOrDecoder, width,\n    height, resampleMethod, signal) {\n    const tileWidth = this.getTileWidth();\n    const tileHeight = this.getTileHeight();\n    const imageWidth = this.getWidth();\n    const imageHeight = this.getHeight();\n\n    const minXTile = Math.max(Math.floor(imageWindow[0] / tileWidth), 0);\n    const maxXTile = Math.min(\n      Math.ceil(imageWindow[2] / tileWidth),\n      Math.ceil(imageWidth / tileWidth),\n    );\n    const minYTile = Math.max(Math.floor(imageWindow[1] / tileHeight), 0);\n    const maxYTile = Math.min(\n      Math.ceil(imageWindow[3] / tileHeight),\n      Math.ceil(imageHeight / tileHeight),\n    );\n    const windowWidth = imageWindow[2] - imageWindow[0];\n\n    let bytesPerPixel = this.getBytesPerPixel();\n\n    const srcSampleOffsets = [];\n    const sampleReaders = [];\n    for (let i = 0; i < samples.length; ++i) {\n      if (this.planarConfiguration === 1) {\n        srcSampleOffsets.push(sum(this.fileDirectory.BitsPerSample, 0, samples[i]) / 8);\n      } else {\n        srcSampleOffsets.push(0);\n      }\n      sampleReaders.push(this.getReaderForSample(samples[i]));\n    }\n\n    const promises = [];\n    const { littleEndian } = this;\n\n    for (let yTile = minYTile; yTile < maxYTile; ++yTile) {\n      for (let xTile = minXTile; xTile < maxXTile; ++xTile) {\n        let getPromise;\n        if (this.planarConfiguration === 1) {\n          getPromise = this.getTileOrStrip(xTile, yTile, 0, poolOrDecoder, signal);\n        }\n        for (let sampleIndex = 0; sampleIndex < samples.length; ++sampleIndex) {\n          const si = sampleIndex;\n          const sample = samples[sampleIndex];\n          if (this.planarConfiguration === 2) {\n            bytesPerPixel = this.getSampleByteSize(sample);\n            getPromise = this.getTileOrStrip(xTile, yTile, sample, poolOrDecoder, signal);\n          }\n          const promise = getPromise.then((tile) => {\n            const buffer = tile.data;\n            const dataView = new DataView(buffer);\n            const blockHeight = this.getBlockHeight(tile.y);\n            const firstLine = tile.y * tileHeight;\n            const firstCol = tile.x * tileWidth;\n            const lastLine = firstLine + blockHeight;\n            const lastCol = (tile.x + 1) * tileWidth;\n            const reader = sampleReaders[si];\n\n            const ymax = Math.min(blockHeight, blockHeight - (lastLine - imageWindow[3]), imageHeight - firstLine);\n            const xmax = Math.min(tileWidth, tileWidth - (lastCol - imageWindow[2]), imageWidth - firstCol);\n\n            for (let y = Math.max(0, imageWindow[1] - firstLine); y < ymax; ++y) {\n              for (let x = Math.max(0, imageWindow[0] - firstCol); x < xmax; ++x) {\n                const pixelOffset = ((y * tileWidth) + x) * bytesPerPixel;\n                const value = reader.call(\n                  dataView, pixelOffset + srcSampleOffsets[si], littleEndian,\n                );\n                let windowCoordinate;\n                if (interleave) {\n                  windowCoordinate = ((y + firstLine - imageWindow[1]) * windowWidth * samples.length)\n                    + ((x + firstCol - imageWindow[0]) * samples.length)\n                    + si;\n                  valueArrays[windowCoordinate] = value;\n                } else {\n                  windowCoordinate = (\n                    (y + firstLine - imageWindow[1]) * windowWidth\n                  ) + x + firstCol - imageWindow[0];\n                  valueArrays[si][windowCoordinate] = value;\n                }\n              }\n            }\n          });\n          promises.push(promise);\n        }\n      }\n    }\n    await Promise.all(promises);\n\n    if ((width && (imageWindow[2] - imageWindow[0]) !== width)\n        || (height && (imageWindow[3] - imageWindow[1]) !== height)) {\n      let resampled;\n      if (interleave) {\n        resampled = resampleInterleaved(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          samples.length,\n          resampleMethod,\n        );\n      } else {\n        resampled = resample(\n          valueArrays,\n          imageWindow[2] - imageWindow[0],\n          imageWindow[3] - imageWindow[1],\n          width, height,\n          resampleMethod,\n        );\n      }\n      resampled.width = width;\n      resampled.height = height;\n      return resampled;\n    }\n\n    valueArrays.width = width || imageWindow[2] - imageWindow[0];\n    valueArrays.height = height || imageWindow[3] - imageWindow[1];\n\n    return valueArrays;\n  }\n\n  /**\n   * Reads raster data from the image. This function reads all selected samples\n   * into separate arrays of the correct type for that sample or into a single\n   * combined array when `interleave` is set. When provided, only a subset\n   * of the raster is read for each sample.\n   *\n   * @param {ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded arrays as a promise\n   */\n  async readRasters({\n    window: wnd, samples = [], interleave, pool = null,\n    width, height, resampleMethod, fillValue, signal,\n  } = {}) {\n    const imageWindow = wnd || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const imageWindowWidth = imageWindow[2] - imageWindow[0];\n    const imageWindowHeight = imageWindow[3] - imageWindow[1];\n    const numPixels = imageWindowWidth * imageWindowHeight;\n    const samplesPerPixel = this.getSamplesPerPixel();\n\n    if (!samples || !samples.length) {\n      for (let i = 0; i < samplesPerPixel; ++i) {\n        samples.push(i);\n      }\n    } else {\n      for (let i = 0; i < samples.length; ++i) {\n        if (samples[i] >= samplesPerPixel) {\n          return Promise.reject(new RangeError(`Invalid sample index '${samples[i]}'.`));\n        }\n      }\n    }\n    let valueArrays;\n    if (interleave) {\n      const format = this.fileDirectory.SampleFormat\n        ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1;\n      const bitsPerSample = Math.max.apply(null, this.fileDirectory.BitsPerSample);\n      valueArrays = arrayForType(format, bitsPerSample, numPixels * samples.length);\n      if (fillValue) {\n        valueArrays.fill(fillValue);\n      }\n    } else {\n      valueArrays = [];\n      for (let i = 0; i < samples.length; ++i) {\n        const valueArray = this.getArrayForSample(samples[i], numPixels);\n        if (Array.isArray(fillValue) && i < fillValue.length) {\n          valueArray.fill(fillValue[i]);\n        } else if (fillValue && !Array.isArray(fillValue)) {\n          valueArray.fill(fillValue);\n        }\n        valueArrays.push(valueArray);\n      }\n    }\n\n    const poolOrDecoder = pool || await getDecoder(this.fileDirectory);\n\n    const result = await this._readRaster(\n      imageWindow, samples, valueArrays, interleave, poolOrDecoder, width, height, resampleMethod, signal,\n    );\n    return result;\n  }\n\n  /**\n   * Reads raster data from the image as RGB. The result is always an\n   * interleaved typed array.\n   * Colorspaces other than RGB will be transformed to RGB, color maps expanded.\n   * When no other method is applicable, the first sample is used to produce a\n   * grayscale image.\n   * When provided, only a subset of the raster is read for each sample.\n   *\n   * @param {Object} [options] optional parameters\n   * @param {Array<number>} [options.window] the subset to read data from in pixels.\n   * @param {boolean} [options.interleave=true] whether the data shall be read\n   *                                             in one single array or separate\n   *                                             arrays.\n   * @param {import(\"./geotiff\").Pool} [options.pool=null] The optional decoder pool to use.\n   * @param {number} [options.width] The desired width of the output. When the width is no the\n   *                                 same as the images, resampling will be performed.\n   * @param {number} [options.height] The desired height of the output. When the width is no the\n   *                                  same as the images, resampling will be performed.\n   * @param {string} [options.resampleMethod='nearest'] The desired resampling method.\n   * @param {boolean} [options.enableAlpha=false] Enable reading alpha channel if present.\n   * @param {AbortSignal} [options.signal] An AbortSignal that may be signalled if the request is\n   *                                       to be aborted\n   * @returns {Promise<ReadRasterResult>} the RGB array as a Promise\n   */\n  async readRGB({ window, interleave = true, pool = null, width, height,\n    resampleMethod, enableAlpha = false, signal } = {}) {\n    const imageWindow = window || [0, 0, this.getWidth(), this.getHeight()];\n\n    // check parameters\n    if (imageWindow[0] > imageWindow[2] || imageWindow[1] > imageWindow[3]) {\n      throw new Error('Invalid subsets');\n    }\n\n    const pi = this.fileDirectory.PhotometricInterpretation;\n\n    if (pi === photometricInterpretations.RGB) {\n      let s = [0, 1, 2];\n      if ((!(this.fileDirectory.ExtraSamples === ExtraSamplesValues.Unspecified)) && enableAlpha) {\n        s = [];\n        for (let i = 0; i < this.fileDirectory.BitsPerSample.length; i += 1) {\n          s.push(i);\n        }\n      }\n      return this.readRasters({\n        window,\n        interleave,\n        samples: s,\n        pool,\n        width,\n        height,\n        resampleMethod,\n        signal,\n      });\n    }\n\n    let samples;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n      case photometricInterpretations.BlackIsZero:\n      case photometricInterpretations.Palette:\n        samples = [0];\n        break;\n      case photometricInterpretations.CMYK:\n        samples = [0, 1, 2, 3];\n        break;\n      case photometricInterpretations.YCbCr:\n      case photometricInterpretations.CIELab:\n        samples = [0, 1, 2];\n        break;\n      default:\n        throw new Error('Invalid or unsupported photometric interpretation.');\n    }\n\n    const subOptions = {\n      window: imageWindow,\n      interleave: true,\n      samples,\n      pool,\n      width,\n      height,\n      resampleMethod,\n      signal,\n    };\n    const { fileDirectory } = this;\n    const raster = await this.readRasters(subOptions);\n\n    const max = 2 ** this.fileDirectory.BitsPerSample[0];\n    let data;\n    switch (pi) {\n      case photometricInterpretations.WhiteIsZero:\n        data = fromWhiteIsZero(raster, max);\n        break;\n      case photometricInterpretations.BlackIsZero:\n        data = fromBlackIsZero(raster, max);\n        break;\n      case photometricInterpretations.Palette:\n        data = fromPalette(raster, fileDirectory.ColorMap);\n        break;\n      case photometricInterpretations.CMYK:\n        data = fromCMYK(raster);\n        break;\n      case photometricInterpretations.YCbCr:\n        data = fromYCbCr(raster);\n        break;\n      case photometricInterpretations.CIELab:\n        data = fromCIELab(raster);\n        break;\n      default:\n        throw new Error('Unsupported photometric interpretation.');\n    }\n\n    // if non-interleaved data is requested, we must split the channels\n    // into their respective arrays\n    if (!interleave) {\n      const red = new Uint8Array(data.length / 3);\n      const green = new Uint8Array(data.length / 3);\n      const blue = new Uint8Array(data.length / 3);\n      for (let i = 0, j = 0; i < data.length; i += 3, ++j) {\n        red[j] = data[i];\n        green[j] = data[i + 1];\n        blue[j] = data[i + 2];\n      }\n      data = [red, green, blue];\n    }\n\n    data.width = raster.width;\n    data.height = raster.height;\n    return data;\n  }\n\n  /**\n   * Returns an array of tiepoints.\n   * @returns {Object[]}\n   */\n  getTiePoints() {\n    if (!this.fileDirectory.ModelTiepoint) {\n      return [];\n    }\n\n    const tiePoints = [];\n    for (let i = 0; i < this.fileDirectory.ModelTiepoint.length; i += 6) {\n      tiePoints.push({\n        i: this.fileDirectory.ModelTiepoint[i],\n        j: this.fileDirectory.ModelTiepoint[i + 1],\n        k: this.fileDirectory.ModelTiepoint[i + 2],\n        x: this.fileDirectory.ModelTiepoint[i + 3],\n        y: this.fileDirectory.ModelTiepoint[i + 4],\n        z: this.fileDirectory.ModelTiepoint[i + 5],\n      });\n    }\n    return tiePoints;\n  }\n\n  /**\n   * Returns the parsed GDAL metadata items.\n   *\n   * If sample is passed to null, dataset-level metadata will be returned.\n   * Otherwise only metadata specific to the provided sample will be returned.\n   *\n   * @param {number} [sample=null] The sample index.\n   * @returns {Object}\n   */\n  getGDALMetadata(sample = null) {\n    const metadata = {};\n    if (!this.fileDirectory.GDAL_METADATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_METADATA;\n\n    let items = findTagsByName(string, 'Item');\n\n    if (sample === null) {\n      items = items.filter((item) => getAttribute(item, 'sample') === undefined);\n    } else {\n      items = items.filter((item) => Number(getAttribute(item, 'sample')) === sample);\n    }\n\n    for (let i = 0; i < items.length; ++i) {\n      const item = items[i];\n      metadata[getAttribute(item, 'name')] = item.inner;\n    }\n    return metadata;\n  }\n\n  /**\n   * Returns the GDAL nodata value\n   * @returns {number|null}\n   */\n  getGDALNoData() {\n    if (!this.fileDirectory.GDAL_NODATA) {\n      return null;\n    }\n    const string = this.fileDirectory.GDAL_NODATA;\n    return Number(string.substring(0, string.length - 1));\n  }\n\n  /**\n   * Returns the image origin as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @returns {Array<number>} The origin as a vector\n   */\n  getOrigin() {\n    const tiePoints = this.fileDirectory.ModelTiepoint;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n    if (tiePoints && tiePoints.length === 6) {\n      return [\n        tiePoints[3],\n        tiePoints[4],\n        tiePoints[5],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[3],\n        modelTransformation[7],\n        modelTransformation[11],\n      ];\n    }\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns the image resolution as a XYZ-vector. When the image has no affine\n   * transformation, then an exception is thrown.\n   * @param {GeoTIFFImage} [referenceImage=null] A reference image to calculate the resolution from\n   *                                             in cases when the current image does not have the\n   *                                             required tags on its own.\n   * @returns {Array<number>} The resolution as a vector\n   */\n  getResolution(referenceImage = null) {\n    const modelPixelScale = this.fileDirectory.ModelPixelScale;\n    const modelTransformation = this.fileDirectory.ModelTransformation;\n\n    if (modelPixelScale) {\n      return [\n        modelPixelScale[0],\n        -modelPixelScale[1],\n        modelPixelScale[2],\n      ];\n    }\n    if (modelTransformation) {\n      return [\n        modelTransformation[0],\n        -modelTransformation[5],\n        modelTransformation[10],\n      ];\n    }\n\n    if (referenceImage) {\n      const [refResX, refResY, refResZ] = referenceImage.getResolution();\n      return [\n        refResX * referenceImage.getWidth() / this.getWidth(),\n        refResY * referenceImage.getHeight() / this.getHeight(),\n        refResZ * referenceImage.getWidth() / this.getWidth(),\n      ];\n    }\n\n    throw new Error('The image does not have an affine transformation.');\n  }\n\n  /**\n   * Returns whether or not the pixels of the image depict an area (or point).\n   * @returns {Boolean} Whether the pixels are a point\n   */\n  pixelIsArea() {\n    return this.geoKeys.GTRasterTypeGeoKey === 1;\n  }\n\n  /**\n   * Returns the image bounding box as an array of 4 values: min-x, min-y,\n   * max-x and max-y. When the image has no affine transformation, then an\n   * exception is thrown.\n   * @param {boolean} [tilegrid=false] If true return extent for a tilegrid \n   *                                   without adjustment for ModelTransformation.\n   * @returns {Array<number>} The bounding box\n   */\n  getBoundingBox(tilegrid = false) {\n    const height = this.getHeight();\n    const width = this.getWidth();\n\n    if (this.fileDirectory.ModelTransformation && !tilegrid) {\n      // eslint-disable-next-line no-unused-vars\n      const [a, b, c, d, e, f, g, h] = this.fileDirectory.ModelTransformation;\n\n      const corners = [\n        [0, 0],\n        [0, height],\n        [width, 0],\n        [width, height],\n      ];\n\n      const projected = corners.map(([I, J]) => [\n        d + (a * I) + (b * J),\n        h + (e * I) + (f * J),\n      ]);\n\n      const xs = projected.map((pt) => pt[0]);\n      const ys = projected.map((pt) => pt[1]);\n\n      return [\n        Math.min(...xs),\n        Math.min(...ys),\n        Math.max(...xs),\n        Math.max(...ys),\n      ];\n    } else {\n      const origin = this.getOrigin();\n      const resolution = this.getResolution();\n\n      const x1 = origin[0];\n      const y1 = origin[1];\n\n      const x2 = x1 + (resolution[0] * width);\n      const y2 = y1 + (resolution[1] * height);\n\n      return [\n        Math.min(x1, x2),\n        Math.min(y1, y2),\n        Math.max(x1, x2),\n        Math.max(y1, y2),\n      ];\n    }\n  }\n}\n\nexport default GeoTIFFImage;\n","import { getFloat16 } from '@petamoriken/float16';\n\nexport default class DataView64 {\n  constructor(arrayBuffer) {\n    this._dataView = new DataView(arrayBuffer);\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  getUint64(offset, littleEndian) {\n    const left = this.getUint32(offset, littleEndian);\n    const right = this.getUint32(offset + 4, littleEndian);\n    let combined;\n    if (littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  getInt64(offset, littleEndian) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (littleEndian ? 7 : 0)) & 0x80) > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(offset + (littleEndian ? i : 7 - i));\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  getUint8(offset, littleEndian) {\n    return this._dataView.getUint8(offset, littleEndian);\n  }\n\n  getInt8(offset, littleEndian) {\n    return this._dataView.getInt8(offset, littleEndian);\n  }\n\n  getUint16(offset, littleEndian) {\n    return this._dataView.getUint16(offset, littleEndian);\n  }\n\n  getInt16(offset, littleEndian) {\n    return this._dataView.getInt16(offset, littleEndian);\n  }\n\n  getUint32(offset, littleEndian) {\n    return this._dataView.getUint32(offset, littleEndian);\n  }\n\n  getInt32(offset, littleEndian) {\n    return this._dataView.getInt32(offset, littleEndian);\n  }\n\n  getFloat16(offset, littleEndian) {\n    return getFloat16(this._dataView, offset, littleEndian);\n  }\n\n  getFloat32(offset, littleEndian) {\n    return this._dataView.getFloat32(offset, littleEndian);\n  }\n\n  getFloat64(offset, littleEndian) {\n    return this._dataView.getFloat64(offset, littleEndian);\n  }\n}\n","export default class DataSlice {\n  constructor(arrayBuffer, sliceOffset, littleEndian, bigTiff) {\n    this._dataView = new DataView(arrayBuffer);\n    this._sliceOffset = sliceOffset;\n    this._littleEndian = littleEndian;\n    this._bigTiff = bigTiff;\n  }\n\n  get sliceOffset() {\n    return this._sliceOffset;\n  }\n\n  get sliceTop() {\n    return this._sliceOffset + this.buffer.byteLength;\n  }\n\n  get littleEndian() {\n    return this._littleEndian;\n  }\n\n  get bigTiff() {\n    return this._bigTiff;\n  }\n\n  get buffer() {\n    return this._dataView.buffer;\n  }\n\n  covers(offset, length) {\n    return this.sliceOffset <= offset && this.sliceTop >= offset + length;\n  }\n\n  readUint8(offset) {\n    return this._dataView.getUint8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt8(offset) {\n    return this._dataView.getInt8(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint16(offset) {\n    return this._dataView.getUint16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt16(offset) {\n    return this._dataView.getInt16(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint32(offset) {\n    return this._dataView.getUint32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readInt32(offset) {\n    return this._dataView.getInt32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat32(offset) {\n    return this._dataView.getFloat32(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readFloat64(offset) {\n    return this._dataView.getFloat64(\n      offset - this._sliceOffset, this._littleEndian,\n    );\n  }\n\n  readUint64(offset) {\n    const left = this.readUint32(offset);\n    const right = this.readUint32(offset + 4);\n    let combined;\n    if (this._littleEndian) {\n      combined = left + ((2 ** 32) * right);\n      if (!Number.isSafeInteger(combined)) {\n        throw new Error(\n          `${combined} exceeds MAX_SAFE_INTEGER. `\n          + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n        );\n      }\n      return combined;\n    }\n    combined = ((2 ** 32) * left) + right;\n    if (!Number.isSafeInteger(combined)) {\n      throw new Error(\n        `${combined} exceeds MAX_SAFE_INTEGER. `\n        + 'Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues',\n      );\n    }\n\n    return combined;\n  }\n\n  // adapted from https://stackoverflow.com/a/55338384/8060591\n  readInt64(offset) {\n    let value = 0;\n    const isNegative = (this._dataView.getUint8(offset + (this._littleEndian ? 7 : 0)) & 0x80)\n      > 0;\n    let carrying = true;\n    for (let i = 0; i < 8; i++) {\n      let byte = this._dataView.getUint8(\n        offset + (this._littleEndian ? i : 7 - i),\n      );\n      if (isNegative) {\n        if (carrying) {\n          if (byte !== 0x00) {\n            byte = ~(byte - 1) & 0xff;\n            carrying = false;\n          }\n        } else {\n          byte = ~byte & 0xff;\n        }\n      }\n      value += byte * (256 ** i);\n    }\n    if (isNegative) {\n      value = -value;\n    }\n    return value;\n  }\n\n  readOffset(offset) {\n    if (this._bigTiff) {\n      return this.readUint64(offset);\n    }\n    return this.readUint32(offset);\n  }\n}\n","import { getDecoder } from './compression/index.js';\n\nconst defaultPoolSize = typeof navigator !== 'undefined' ? (navigator.hardwareConcurrency || 2) : 2;\n\n/**\n * @module pool\n */\n\n/**\n * Pool for workers to decode chunks of the images.\n */\nclass Pool {\n  /**\n   * @constructor\n   * @param {Number} [size] The size of the pool. Defaults to the number of CPUs\n   *                      available. When this parameter is `null` or 0, then the\n   *                      decoding will be done in the main thread.\n   * @param {function(): Worker} [createWorker] A function that creates the decoder worker.\n   * Defaults to a worker with all decoders that ship with geotiff.js. The `createWorker()`\n   * function is expected to return a `Worker` compatible with Web Workers. For code that\n   * runs in Node, [web-worker](https://www.npmjs.com/package/web-worker) is a good choice.\n   *\n   * A worker that uses a custom lzw decoder would look like this `my-custom-worker.js` file:\n   * ```js\n   * import { addDecoder, getDecoder } from 'geotiff';\n   * addDecoder(5, () => import ('./my-custom-lzw').then((m) => m.default));\n   * self.addEventListener('message', async (e) => {\n   *   const { id, fileDirectory, buffer } = e.data;\n   *   const decoder = await getDecoder(fileDirectory);\n   *   const decoded = await decoder.decode(fileDirectory, buffer);\n   *   self.postMessage({ decoded, id }, [decoded]);\n   * });\n   * ```\n   * The way the above code is built into a worker by the `createWorker()` function\n   * depends on the used bundler. For most bundlers, something like this will work:\n   * ```js\n   * function createWorker() {\n   *   return new Worker(new URL('./my-custom-worker.js', import.meta.url));\n   * }\n   * ```\n   */\n  constructor(size = defaultPoolSize, createWorker) {\n    this.workers = null;\n    this._awaitingDecoder = null;\n    this.size = size;\n    this.messageId = 0;\n    if (size) {\n      this._awaitingDecoder = createWorker ? Promise.resolve(createWorker) : new Promise((resolve) => {\n        import('./worker/decoder.js').then((module) => {\n          resolve(module.create);\n        });\n      });\n      this._awaitingDecoder.then((create) => {\n        this._awaitingDecoder = null;\n        this.workers = [];\n        for (let i = 0; i < size; i++) {\n          this.workers.push({ worker: create(), idle: true });\n        }\n      });\n    }\n  }\n\n  /**\n   * Decode the given block of bytes with the set compression method.\n   * @param {ArrayBuffer} buffer the array buffer of bytes to decode.\n   * @returns {Promise<ArrayBuffer>} the decoded result as a `Promise`\n   */\n  async decode(fileDirectory, buffer) {\n    if (this._awaitingDecoder) {\n      await this._awaitingDecoder;\n    }\n    return this.size === 0\n      ? getDecoder(fileDirectory).then((decoder) => decoder.decode(fileDirectory, buffer))\n      : new Promise((resolve) => {\n        const worker = this.workers.find((candidate) => candidate.idle)\n          || this.workers[Math.floor(Math.random() * this.size)];\n        worker.idle = false;\n        const id = this.messageId++;\n        const onMessage = (e) => {\n          if (e.data.id === id) {\n            worker.idle = true;\n            resolve(e.data.decoded);\n            worker.worker.removeEventListener('message', onMessage);\n          }\n        };\n        worker.worker.addEventListener('message', onMessage);\n        worker.worker.postMessage({ fileDirectory, buffer, id }, [buffer]);\n      });\n  }\n\n  destroy() {\n    if (this.workers) {\n      this.workers.forEach((worker) => {\n        worker.worker.terminate();\n      });\n      this.workers = null;\n    }\n  }\n}\n\nexport default Pool;\n","const CRLFCRLF = '\\r\\n\\r\\n';\n\n/*\n * Shim for 'Object.fromEntries'\n */\nfunction itemsToObject(items) {\n  if (typeof Object.fromEntries !== 'undefined') {\n    return Object.fromEntries(items);\n  }\n  const obj = {};\n  for (const [key, value] of items) {\n    obj[key.toLowerCase()] = value;\n  }\n  return obj;\n}\n\n/**\n * Parse HTTP headers from a given string.\n * @param {String} text the text to parse the headers from\n * @returns {Object} the parsed headers with lowercase keys\n */\nfunction parseHeaders(text) {\n  const items = text\n    .split('\\r\\n')\n    .map((line) => {\n      const kv = line.split(':').map((str) => str.trim());\n      kv[0] = kv[0].toLowerCase();\n      return kv;\n    });\n\n  return itemsToObject(items);\n}\n\n/**\n * Parse a 'Content-Type' header value to the content-type and parameters\n * @param {String} rawContentType the raw string to parse from\n * @returns {Object} the parsed content type with the fields: type and params\n */\nexport function parseContentType(rawContentType) {\n  const [type, ...rawParams] = rawContentType.split(';').map((s) => s.trim());\n  const paramsItems = rawParams.map((param) => param.split('='));\n  return { type, params: itemsToObject(paramsItems) };\n}\n\n/**\n * Parse a 'Content-Range' header value to its start, end, and total parts\n * @param {String} rawContentRange the raw string to parse from\n * @returns {Object} the parsed parts\n */\nexport function parseContentRange(rawContentRange) {\n  let start;\n  let end;\n  let total;\n\n  if (rawContentRange) {\n    [, start, end, total] = rawContentRange.match(/bytes (\\d+)-(\\d+)\\/(\\d+)/);\n    start = parseInt(start, 10);\n    end = parseInt(end, 10);\n    total = parseInt(total, 10);\n  }\n\n  return { start, end, total };\n}\n\n/**\n * Parses a list of byteranges from the given 'multipart/byteranges' HTTP response.\n * Each item in the list has the following properties:\n * - headers: the HTTP headers\n * - data: the sliced ArrayBuffer for that specific part\n * - offset: the offset of the byterange within its originating file\n * - length: the length of the byterange\n * @param {ArrayBuffer} responseArrayBuffer the response to be parsed and split\n * @param {String} boundary the boundary string used to split the sections\n * @returns {Object[]} the parsed byteranges\n */\nexport function parseByteRanges(responseArrayBuffer, boundary) {\n  let offset = null;\n  const decoder = new TextDecoder('ascii');\n  const out = [];\n\n  const startBoundary = `--${boundary}`;\n  const endBoundary = `${startBoundary}--`;\n\n  // search for the initial boundary, may be offset by some bytes\n  // TODO: more efficient to check for `--` in bytes directly\n  for (let i = 0; i < 10; ++i) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, i, startBoundary.length),\n    );\n    if (text === startBoundary) {\n      offset = i;\n    }\n  }\n\n  if (offset === null) {\n    throw new Error('Could not find initial boundary');\n  }\n\n  while (offset < responseArrayBuffer.byteLength) {\n    const text = decoder.decode(\n      new Uint8Array(responseArrayBuffer, offset,\n        Math.min(startBoundary.length + 1024, responseArrayBuffer.byteLength - offset),\n      ),\n    );\n\n    // break if we arrived at the end\n    if (text.length === 0 || text.startsWith(endBoundary)) {\n      break;\n    }\n\n    // assert that we are actually dealing with a byterange and are at the correct offset\n    if (!text.startsWith(startBoundary)) {\n      throw new Error('Part does not start with boundary');\n    }\n\n    // get a substring from where we read the headers\n    const innerText = text.substr(startBoundary.length + 2);\n\n    if (innerText.length === 0) {\n      break;\n    }\n\n    // find the double linebreak that denotes the end of the headers\n    const endOfHeaders = innerText.indexOf(CRLFCRLF);\n\n    // parse the headers to get the content range size\n    const headers = parseHeaders(innerText.substr(0, endOfHeaders));\n    const { start, end, total } = parseContentRange(headers['content-range']);\n\n    // calculate the length of the slice and the next offset\n    const startOfData = offset + startBoundary.length + endOfHeaders + CRLFCRLF.length;\n    const length = parseInt(end, 10) + 1 - parseInt(start, 10);\n    out.push({\n      headers,\n      data: responseArrayBuffer.slice(startOfData, startOfData + length),\n      offset: start,\n      length,\n      fileSize: total,\n    });\n\n    offset = startOfData + length + 4;\n  }\n\n  return out;\n}\n","/**\n * @typedef Slice\n * @property {number} offset\n * @property {number} length\n */\n\nexport class BaseSource {\n  /**\n   *\n   * @param {Slice[]} slices\n   * @returns {ArrayBuffer[]}\n   */\n  async fetch(slices, signal = undefined) {\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  /**\n   *\n   * @param {Slice} slice\n   * @returns {ArrayBuffer}\n   */\n  async fetchSlice(slice) {\n    throw new Error(`fetching of slice ${slice} not possible, not implemented`);\n  }\n\n  /**\n   * Returns the filesize if already determined and null otherwise\n   */\n  get fileSize() {\n    return null;\n  }\n\n  async close() {\n    // no-op by default\n  }\n}\n","export default class QuickLRU extends Map {\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tif (typeof options.maxAge === 'number' && options.maxAge === 0) {\n\t\t\tthrow new TypeError('`maxAge` must be a number greater than 0');\n\t\t}\n\n\t\t// TODO: Use private class fields when ESLint supports them.\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.maxAge = options.maxAge || Number.POSITIVE_INFINITY;\n\t\tthis.onEviction = options.onEviction;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t// TODO: Use private class methods when targeting Node.js 16.\n\t_emitEvictions(cache) {\n\t\tif (typeof this.onEviction !== 'function') {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const [key, item] of cache) {\n\t\t\tthis.onEviction(key, item.value);\n\t\t}\n\t}\n\n\t_deleteIfExpired(key, item) {\n\t\tif (typeof item.expiry === 'number' && item.expiry <= Date.now()) {\n\t\t\tif (typeof this.onEviction === 'function') {\n\t\t\t\tthis.onEviction(key, item.value);\n\t\t\t}\n\n\t\t\treturn this.delete(key);\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t_getOrDeleteIfExpired(key, item) {\n\t\tconst deleted = this._deleteIfExpired(key, item);\n\t\tif (deleted === false) {\n\t\t\treturn item.value;\n\t\t}\n\t}\n\n\t_getItemValue(key, item) {\n\t\treturn item.expiry ? this._getOrDeleteIfExpired(key, item) : item.value;\n\t}\n\n\t_peek(key, cache) {\n\t\tconst item = cache.get(key);\n\n\t\treturn this._getItemValue(key, item);\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\t\t\tthis._emitEvictions(this.oldCache);\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\t_moveToRecent(key, item) {\n\t\tthis.oldCache.delete(key);\n\t\tthis._set(key, item);\n\t}\n\n\t* _entriesAscending() {\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield item;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\tconst item = this.cache.get(key);\n\n\t\t\treturn this._getItemValue(key, item);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst item = this.oldCache.get(key);\n\t\t\tif (this._deleteIfExpired(key, item) === false) {\n\t\t\t\tthis._moveToRecent(key, item);\n\t\t\t\treturn item.value;\n\t\t\t}\n\t\t}\n\t}\n\n\tset(key, value, {maxAge = this.maxAge} = {}) {\n\t\tconst expiry =\n\t\t\ttypeof maxAge === 'number' && maxAge !== Number.POSITIVE_INFINITY ?\n\t\t\t\tDate.now() + maxAge :\n\t\t\t\tundefined;\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, {\n\t\t\t\tvalue,\n\t\t\t\texpiry\n\t\t\t});\n\t\t} else {\n\t\t\tthis._set(key, {value, expiry});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.cache.get(key));\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn !this._deleteIfExpired(key, this.oldCache.get(key));\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this._peek(key, this.cache);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this._peek(key, this.oldCache);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\tresize(newSize) {\n\t\tif (!(newSize && newSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tconst items = [...this._entriesAscending()];\n\t\tconst removeCount = items.length - newSize;\n\t\tif (removeCount < 0) {\n\t\t\tthis.cache = new Map(items);\n\t\t\tthis.oldCache = new Map();\n\t\t\tthis._size = items.length;\n\t\t} else {\n\t\t\tif (removeCount > 0) {\n\t\t\t\tthis._emitEvictions(items.slice(0, removeCount));\n\t\t\t}\n\n\t\t\tthis.oldCache = new Map(items.slice(removeCount));\n\t\t\tthis.cache = new Map();\n\t\t\tthis._size = 0;\n\t\t}\n\n\t\tthis.maxSize = newSize;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesDescending() {\n\t\tlet items = [...this.cache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\tif (deleted === false) {\n\t\t\t\tyield [key, value.value];\n\t\t\t}\n\t\t}\n\n\t\titems = [...this.oldCache];\n\t\tfor (let i = items.length - 1; i >= 0; --i) {\n\t\t\tconst item = items[i];\n\t\t\tconst [key, value] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tconst deleted = this._deleteIfExpired(key, value);\n\t\t\t\tif (deleted === false) {\n\t\t\t\t\tyield [key, value.value];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t* entriesAscending() {\n\t\tfor (const [key, value] of this._entriesAscending()) {\n\t\t\tyield [key, value.value];\n\t\t}\n\t}\n\n\tget size() {\n\t\tif (!this._size) {\n\t\t\treturn this.oldCache.size;\n\t\t}\n\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(this._size + oldCacheSize, this.maxSize);\n\t}\n\n\tentries() {\n\t\treturn this.entriesAscending();\n\t}\n\n\tforEach(callbackFunction, thisArgument = this) {\n\t\tfor (const [key, value] of this.entriesAscending()) {\n\t\t\tcallbackFunction.call(thisArgument, value, key, this);\n\t\t}\n\t}\n\n\tget [Symbol.toStringTag]() {\n\t\treturn JSON.stringify([...this.entriesAscending()]);\n\t}\n}\n","export function assign(target, source) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n\nexport function chunk(iterable, length) {\n  const results = [];\n  const lengthOfIterable = iterable.length;\n  for (let i = 0; i < lengthOfIterable; i += length) {\n    const chunked = [];\n    for (let ci = i; ci < i + length; ci++) {\n      chunked.push(iterable[ci]);\n    }\n    results.push(chunked);\n  }\n  return results;\n}\n\nexport function endsWith(string, expectedEnding) {\n  if (string.length < expectedEnding.length) {\n    return false;\n  }\n  const actualEnding = string.substr(string.length - expectedEnding.length);\n  return actualEnding === expectedEnding;\n}\n\nexport function forEach(iterable, func) {\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    func(iterable[i], i);\n  }\n}\n\nexport function invert(oldObj) {\n  const newObj = {};\n  for (const key in oldObj) {\n    if (oldObj.hasOwnProperty(key)) {\n      const value = oldObj[key];\n      newObj[value] = key;\n    }\n  }\n  return newObj;\n}\n\nexport function range(n) {\n  const results = [];\n  for (let i = 0; i < n; i++) {\n    results.push(i);\n  }\n  return results;\n}\n\nexport function times(numTimes, func) {\n  const results = [];\n  for (let i = 0; i < numTimes; i++) {\n    results.push(func(i));\n  }\n  return results;\n}\n\nexport function toArray(iterable) {\n  const results = [];\n  const { length } = iterable;\n  for (let i = 0; i < length; i++) {\n    results.push(iterable[i]);\n  }\n  return results;\n}\n\nexport function toArrayRecursively(input) {\n  if (input.length) {\n    return toArray(input).map(toArrayRecursively);\n  }\n  return input;\n}\n\n// copied from https://github.com/academia-de-codigo/parse-content-range-header/blob/master/index.js\nexport function parseContentRange(headerValue) {\n  if (!headerValue) {\n    return null;\n  }\n\n  if (typeof headerValue !== 'string') {\n    throw new Error('invalid argument');\n  }\n\n  const parseInt = (number) => Number.parseInt(number, 10);\n\n  // Check for presence of unit\n  let matches = headerValue.match(/^(\\w*) /);\n  const unit = matches && matches[1];\n\n  // check for start-end/size header format\n  matches = headerValue.match(/(\\d+)-(\\d+)\\/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: parseInt(matches[1]),\n      last: parseInt(matches[2]),\n      length: matches[3] === '*' ? null : parseInt(matches[3]),\n    };\n  }\n\n  // check for size header format\n  matches = headerValue.match(/(\\d+|\\*)/);\n  if (matches) {\n    return {\n      unit,\n      first: null,\n      last: null,\n      length: matches[1] === '*' ? null : parseInt(matches[1]),\n    };\n  }\n\n  return null;\n}\n\n/*\n * Promisified wrapper around 'setTimeout' to allow 'await'\n */\nexport async function wait(milliseconds) {\n  return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nexport function zip(a, b) {\n  const A = Array.isArray(a) ? a : Array.from(a);\n  const B = Array.isArray(b) ? b : Array.from(b);\n  return A.map((k, i) => [k, B[i]]);\n}\n\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error\nexport class AbortError extends Error {\n  constructor(params) {\n    // Pass remaining arguments (including vendor specific ones) to parent constructor\n    super(params);\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, AbortError);\n    }\n\n    this.name = 'AbortError';\n  }\n}\n\nexport class CustomAggregateError extends Error {\n  constructor(errors, message) {\n    super(message);\n    this.errors = errors;\n    this.message = message;\n    this.name = 'AggregateError';\n  }\n}\n\nexport const AggregateError = CustomAggregateError;\n","import QuickLRU from 'quick-lru';\nimport { BaseSource } from './basesource.js';\nimport { AbortError, AggregateError, wait, zip } from '../utils.js';\n\nclass Block {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {ArrayBuffer} [data]\n   */\n  constructor(offset, length, data = null) {\n    this.offset = offset;\n    this.length = length;\n    this.data = data;\n  }\n\n  /**\n   * @returns {number} the top byte border\n   */\n  get top() {\n    return this.offset + this.length;\n  }\n}\n\nclass BlockGroup {\n  /**\n   *\n   * @param {number} offset\n   * @param {number} length\n   * @param {number[]} blockIds\n   */\n  constructor(offset, length, blockIds) {\n    this.offset = offset;\n    this.length = length;\n    this.blockIds = blockIds;\n  }\n}\n\nexport class BlockedSource extends BaseSource {\n  /**\n   *\n   * @param {BaseSource} source The underlying source that shall be blocked and cached\n   * @param {object} options\n   * @param {number} [options.blockSize]\n   * @param {number} [options.cacheSize]\n   */\n  constructor(source, { blockSize = 65536, cacheSize = 100 } = {}) {\n    super();\n    this.source = source;\n    this.blockSize = blockSize;\n\n    this.blockCache = new QuickLRU({\n      maxSize: cacheSize,\n      onEviction: (blockId, block) => {\n        this.evictedBlocks.set(blockId, block);\n      },\n    });\n\n    /** @type {Map<number, Block>} */\n    this.evictedBlocks = new Map();\n\n    // mapping blockId -> Block instance\n    this.blockRequests = new Map();\n\n    // set of blockIds missing for the current requests\n    this.blockIdsToFetch = new Set();\n\n    this.abortedBlockIds = new Set();\n  }\n\n  get fileSize() {\n    return this.source.fileSize;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    const blockRequests = [];\n    const missingBlockIds = [];\n    const allBlockIds = [];\n    this.evictedBlocks.clear();\n\n    for (const { offset, length } of slices) {\n      let top = offset + length;\n\n      const { fileSize } = this;\n      if (fileSize !== null) {\n        top = Math.min(top, fileSize);\n      }\n\n      const firstBlockOffset = Math.floor(offset / this.blockSize) * this.blockSize;\n\n      for (let current = firstBlockOffset; current < top; current += this.blockSize) {\n        const blockId = Math.floor(current / this.blockSize);\n        if (!this.blockCache.has(blockId) && !this.blockRequests.has(blockId)) {\n          this.blockIdsToFetch.add(blockId);\n          missingBlockIds.push(blockId);\n        }\n        if (this.blockRequests.has(blockId)) {\n          blockRequests.push(this.blockRequests.get(blockId));\n        }\n        allBlockIds.push(blockId);\n      }\n    }\n\n    // allow additional block requests to accumulate\n    await wait();\n    this.fetchBlocks(signal);\n\n    // Gather all of the new requests that this fetch call is contributing to `fetch`.\n    const missingRequests = [];\n    for (const blockId of missingBlockIds) {\n      // The requested missing block could already be in the cache\n      // instead of having its request still be outstanding.\n      if (this.blockRequests.has(blockId)) {\n        missingRequests.push(this.blockRequests.get(blockId));\n      }\n    }\n\n    // Actually await all pending requests that are needed for this `fetch`.\n    await Promise.allSettled(blockRequests);\n    await Promise.allSettled(missingRequests);\n\n    // Perform retries if a block was interrupted by a previous signal\n    const abortedBlockRequests = [];\n    const abortedBlockIds = allBlockIds\n      .filter((id) => this.abortedBlockIds.has(id) || !this.blockCache.has(id));\n    abortedBlockIds.forEach((id) => this.blockIdsToFetch.add(id));\n    // start the retry of some blocks if required\n    if (abortedBlockIds.length > 0 && signal && !signal.aborted) {\n      this.fetchBlocks(null);\n      for (const blockId of abortedBlockIds) {\n        const block = this.blockRequests.get(blockId);\n        if (!block) {\n          throw new Error(`Block ${blockId} is not in the block requests`);\n        }\n        abortedBlockRequests.push(block);\n      }\n      await Promise.allSettled(abortedBlockRequests);\n    }\n\n    // throw an  abort error\n    if (signal && signal.aborted) {\n      throw new AbortError('Request was aborted');\n    }\n\n    const blocks = allBlockIds.map((id) => this.blockCache.get(id) || this.evictedBlocks.get(id));\n    const failedBlocks = blocks.filter((i) => !i);\n    if (failedBlocks.length) {\n      throw new AggregateError(failedBlocks, 'Request failed');\n    }\n\n    // create a final Map, with all required blocks for this request to satisfy\n    const requiredBlocks = new Map(zip(allBlockIds, blocks));\n\n    // TODO: satisfy each slice\n    return this.readSliceData(slices, requiredBlocks);\n  }\n\n  /**\n   *\n   * @param {AbortSignal} signal\n   */\n  fetchBlocks(signal) {\n    // check if we still need to\n    if (this.blockIdsToFetch.size > 0) {\n      const groups = this.groupBlocks(this.blockIdsToFetch);\n\n      // start requesting slices of data\n      const groupRequests = this.source.fetch(groups, signal);\n\n      for (let groupIndex = 0; groupIndex < groups.length; ++groupIndex) {\n        const group = groups[groupIndex];\n\n        for (const blockId of group.blockIds) {\n          // make an async IIFE for each block\n          this.blockRequests.set(blockId, (async () => {\n            try {\n              const response = (await groupRequests)[groupIndex];\n              const blockOffset = blockId * this.blockSize;\n              const o = blockOffset - response.offset;\n              const t = Math.min(o + this.blockSize, response.data.byteLength);\n              const data = response.data.slice(o, t);\n              const block = new Block(\n                blockOffset,\n                data.byteLength,\n                data,\n                blockId,\n              );\n              this.blockCache.set(blockId, block);\n              this.abortedBlockIds.delete(blockId);\n            } catch (err) {\n              if (err.name === 'AbortError') {\n                // store the signal here, we need it to determine later if an\n                // error was caused by this signal\n                err.signal = signal;\n                this.blockCache.delete(blockId);\n                this.abortedBlockIds.add(blockId);\n              } else {\n                throw err;\n              }\n            } finally {\n              this.blockRequests.delete(blockId);\n            }\n          })());\n        }\n      }\n      this.blockIdsToFetch.clear();\n    }\n  }\n\n  /**\n   *\n   * @param {Set} blockIds\n   * @returns {BlockGroup[]}\n   */\n  groupBlocks(blockIds) {\n    const sortedBlockIds = Array.from(blockIds).sort((a, b) => a - b);\n    if (sortedBlockIds.length === 0) {\n      return [];\n    }\n    let current = [];\n    let lastBlockId = null;\n    const groups = [];\n\n    for (const blockId of sortedBlockIds) {\n      if (lastBlockId === null || lastBlockId + 1 === blockId) {\n        current.push(blockId);\n        lastBlockId = blockId;\n      } else {\n        groups.push(new BlockGroup(\n          current[0] * this.blockSize,\n          current.length * this.blockSize,\n          current,\n        ));\n        current = [blockId];\n        lastBlockId = blockId;\n      }\n    }\n\n    groups.push(new BlockGroup(\n      current[0] * this.blockSize,\n      current.length * this.blockSize,\n      current,\n    ));\n\n    return groups;\n  }\n\n  /**\n   *\n   * @param {import(\"./basesource\").Slice[]} slices\n   * @param {Map} blocks\n   */\n  readSliceData(slices, blocks) {\n    return slices.map((slice) => {\n      let top = slice.offset + slice.length;\n      if (this.fileSize !== null) {\n        top = Math.min(this.fileSize, top);\n      }\n      const blockIdLow = Math.floor(slice.offset / this.blockSize);\n      const blockIdHigh = Math.floor(top / this.blockSize);\n      const sliceData = new ArrayBuffer(slice.length);\n      const sliceView = new Uint8Array(sliceData);\n\n      for (let blockId = blockIdLow; blockId <= blockIdHigh; ++blockId) {\n        const block = blocks.get(blockId);\n        const delta = block.offset - slice.offset;\n        const topDelta = block.top - top;\n        let blockInnerOffset = 0;\n        let rangeInnerOffset = 0;\n        let usedBlockLength;\n\n        if (delta < 0) {\n          blockInnerOffset = -delta;\n        } else if (delta > 0) {\n          rangeInnerOffset = delta;\n        }\n\n        if (topDelta < 0) {\n          usedBlockLength = block.length - blockInnerOffset;\n        } else {\n          usedBlockLength = top - block.offset - blockInnerOffset;\n        }\n\n        const blockView = new Uint8Array(block.data, blockInnerOffset, usedBlockLength);\n        sliceView.set(blockView, rangeInnerOffset);\n      }\n\n      return sliceData;\n    });\n  }\n}\n","export class BaseResponse {\n  /**\n   * Returns whether the response has an ok'ish status code\n   */\n  get ok() {\n    return this.status >= 200 && this.status <= 299;\n  }\n\n  /**\n   * Returns the status code of the response\n   */\n  get status() {\n    throw new Error('not implemented');\n  }\n\n  /**\n   * Returns the value of the specified header\n   * @param {string} headerName the header name\n   * @returns {string} the header value\n   */\n  getHeader(headerName) { // eslint-disable-line no-unused-vars\n    throw new Error('not implemented');\n  }\n\n  /**\n   * @returns {ArrayBuffer} the response data of the request\n   */\n  async getData() {\n    throw new Error('not implemented');\n  }\n}\n\nexport class BaseClient {\n  constructor(url) {\n    this.url = url;\n  }\n\n  /**\n   * Send a request with the options\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<BaseResponse>}\n   */\n  async request({ headers, signal } = {}) { // eslint-disable-line no-unused-vars\n    throw new Error('request is not implemented');\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\n\nclass FetchResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for fetch API Response\n   * @param {Response} response\n   */\n  constructor(response) {\n    super();\n    this.response = response;\n  }\n\n  get status() {\n    return this.response.status;\n  }\n\n  getHeader(name) {\n    return this.response.headers.get(name);\n  }\n\n  async getData() {\n    const data = this.response.arrayBuffer\n      ? await this.response.arrayBuffer()\n      : (await this.response.buffer()).buffer;\n    return data;\n  }\n}\n\nexport class FetchClient extends BaseClient {\n  constructor(url, credentials) {\n    super(url);\n    this.credentials = credentials;\n  }\n\n  /**\n   * @param {{headers: HeadersInit, signal: AbortSignal}} [options={}]\n   * @returns {Promise<FetchResponse>}\n   */\n  async request({ headers, signal } = {}) {\n    const response = await fetch(this.url, {\n      headers, credentials: this.credentials, signal,\n    });\n    return new FetchResponse(response);\n  }\n}\n","import { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass XHRResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for XMLHttpRequest\n   * @param {XMLHttpRequest} xhr\n   * @param {ArrayBuffer} data\n   */\n  constructor(xhr, data) {\n    super();\n    this.xhr = xhr;\n    this.data = data;\n  }\n\n  get status() {\n    return this.xhr.status;\n  }\n\n  getHeader(name) {\n    return this.xhr.getResponseHeader(name);\n  }\n\n  async getData() {\n    return this.data;\n  }\n}\n\nexport class XHRClient extends BaseClient {\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.open('GET', this.url);\n      xhr.responseType = 'arraybuffer';\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n\n      // hook signals\n      xhr.onload = () => {\n        const data = xhr.response;\n        resolve(new XHRResponse(xhr, data));\n      };\n      xhr.onerror = reject;\n      xhr.onabort = () => reject(new AbortError('Request aborted'));\n      xhr.send();\n\n      if (signal) {\n        if (signal.aborted) {\n          xhr.abort();\n        }\n        signal.addEventListener('abort', () => xhr.abort());\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","export default {}","import http from 'http';\nimport https from 'https';\nimport urlMod from 'url';\n\nimport { BaseClient, BaseResponse } from './base.js';\nimport { AbortError } from '../../utils.js';\n\nclass HttpResponse extends BaseResponse {\n  /**\n   * BaseResponse facade for node HTTP/HTTPS API Response\n   * @param {http.ServerResponse} response\n   */\n  constructor(response, dataPromise) {\n    super();\n    this.response = response;\n    this.dataPromise = dataPromise;\n  }\n\n  get status() {\n    return this.response.statusCode;\n  }\n\n  getHeader(name) {\n    return this.response.headers[name];\n  }\n\n  async getData() {\n    const data = await this.dataPromise;\n    return data;\n  }\n}\n\nexport class HttpClient extends BaseClient {\n  constructor(url) {\n    super(url);\n    this.parsedUrl = urlMod.parse(this.url);\n    this.httpApi = (this.parsedUrl.protocol === 'http:' ? http : https);\n  }\n\n  constructRequest(headers, signal) {\n    return new Promise((resolve, reject) => {\n      const request = this.httpApi.get(\n        {\n          ...this.parsedUrl,\n          headers,\n        },\n        (response) => {\n          const dataPromise = new Promise((resolveData) => {\n            const chunks = [];\n\n            // collect chunks\n            response.on('data', (chunk) => {\n              chunks.push(chunk);\n            });\n\n            // concatenate all chunks and resolve the promise with the resulting buffer\n            response.on('end', () => {\n              const data = Buffer.concat(chunks).buffer;\n              resolveData(data);\n            });\n            response.on('error', reject);\n          });\n          resolve(new HttpResponse(response, dataPromise));\n        },\n      );\n      request.on('error', reject);\n\n      if (signal) {\n        if (signal.aborted) {\n          request.destroy(new AbortError('Request aborted'));\n        }\n        signal.addEventListener('abort', () => request.destroy(new AbortError('Request aborted')));\n      }\n    });\n  }\n\n  async request({ headers, signal } = {}) {\n    const response = await this.constructRequest(headers, signal);\n    return response;\n  }\n}\n","import { parseByteRanges, parseContentRange, parseContentType } from './httputils.js';\nimport { BaseSource } from './basesource.js';\nimport { BlockedSource } from './blockedsource.js';\n\nimport { FetchClient } from './client/fetch.js';\nimport { XHRClient } from './client/xhr.js';\nimport { HttpClient } from './client/http.js';\n\nclass RemoteSource extends BaseSource {\n  /**\n   *\n   * @param {BaseClient} client\n   * @param {object} headers\n   * @param {numbers} maxRanges\n   * @param {boolean} allowFullFile\n   */\n  constructor(client, headers, maxRanges, allowFullFile) {\n    super();\n    this.client = client;\n    this.headers = headers;\n    this.maxRanges = maxRanges;\n    this.allowFullFile = allowFullFile;\n    this._fileSize = null;\n  }\n\n  /**\n   *\n   * @param {Slice[]} slices\n   */\n  async fetch(slices, signal) {\n    // if we allow multi-ranges, split the incoming request into that many sub-requests\n    // and join them afterwards\n    if (this.maxRanges >= slices.length) {\n      return this.fetchSlices(slices, signal);\n    } else if (this.maxRanges > 0 && slices.length > 1) {\n      // TODO: split into multiple multi-range requests\n\n      // const subSlicesRequests = [];\n      // for (let i = 0; i < slices.length; i += this.maxRanges) {\n      //   subSlicesRequests.push(\n      //     this.fetchSlices(slices.slice(i, i + this.maxRanges), signal),\n      //   );\n      // }\n      // return (await Promise.all(subSlicesRequests)).flat();\n    }\n\n    // otherwise make a single request for each slice\n    return Promise.all(\n      slices.map((slice) => this.fetchSlice(slice, signal)),\n    );\n  }\n\n  async fetchSlices(slices, signal) {\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${slices\n          .map(({ offset, length }) => `${offset}-${offset + length}`)\n          .join(',')\n        }`,\n      },\n      signal,\n    });\n\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const { type, params } = parseContentType(response.getHeader('content-type'));\n      if (type === 'multipart/byteranges') {\n        const byteRanges = parseByteRanges(await response.getData(), params.boundary);\n        this._fileSize = byteRanges[0].fileSize || null;\n        return byteRanges;\n      }\n\n      const data = await response.getData();\n\n      const { start, end, total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      const first = [{\n        data,\n        offset: start,\n        length: end - start,\n      }];\n\n      if (slices.length > 1) {\n        // we requested more than one slice, but got only the first\n        // unfortunately, some HTTP Servers don't support multi-ranges\n        // and return only the first\n\n        // get the rest of the slices and fetch them iteratively\n        const others = await Promise.all(slices.slice(1).map((slice) => this.fetchSlice(slice, signal)));\n        return first.concat(others);\n      }\n      return first;\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n      const data = await response.getData();\n      this._fileSize = data.byteLength;\n      return [{\n        data,\n        offset: 0,\n        length: data.byteLength,\n      }];\n    }\n  }\n\n  async fetchSlice(slice, signal) {\n    const { offset, length } = slice;\n    const response = await this.client.request({\n      headers: {\n        ...this.headers,\n        Range: `bytes=${offset}-${offset + length}`,\n      },\n      signal,\n    });\n\n    // check the response was okay and if the server actually understands range requests\n    if (!response.ok) {\n      throw new Error('Error fetching data.');\n    } else if (response.status === 206) {\n      const data = await response.getData();\n\n      const { total } = parseContentRange(response.getHeader('content-range'));\n      this._fileSize = total || null;\n      return {\n        data,\n        offset,\n        length,\n      };\n    } else {\n      if (!this.allowFullFile) {\n        throw new Error('Server responded with full file');\n      }\n\n      const data = await response.getData();\n\n      this._fileSize = data.byteLength;\n      return {\n        data,\n        offset: 0,\n        length: data.byteLength,\n      };\n    }\n  }\n\n  get fileSize() {\n    return this._fileSize;\n  }\n}\n\nfunction maybeWrapInBlockedSource(source, { blockSize, cacheSize }) {\n  if (blockSize === null) {\n    return source;\n  }\n  return new BlockedSource(source, { blockSize, cacheSize });\n}\n\nexport function makeFetchSource(url, { headers = {}, credentials, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new FetchClient(url, credentials);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeXHRSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new XHRClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeHttpSource(url, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const client = new HttpClient(url);\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\nexport function makeCustomSource(client, { headers = {}, maxRanges = 0, allowFullFile = false, ...blockOptions } = {}) {\n  const source = new RemoteSource(client, headers, maxRanges, allowFullFile);\n  return maybeWrapInBlockedSource(source, blockOptions);\n}\n\n/**\n *\n * @param {string} url\n * @param {object} options\n */\nexport function makeRemoteSource(url, { forceXHR = false, ...clientOptions } = {}) {\n  if (typeof fetch === 'function' && !forceXHR) {\n    return makeFetchSource(url, clientOptions);\n  }\n  if (typeof XMLHttpRequest !== 'undefined') {\n    return makeXHRSource(url, clientOptions);\n  }\n  return makeHttpSource(url, clientOptions);\n}\n","import { BaseSource } from './basesource.js';\n\nclass FileReaderSource extends BaseSource {\n  constructor(file) {\n    super();\n    this.file = file;\n  }\n\n  async fetchSlice(slice, signal) {\n    return new Promise((resolve, reject) => {\n      const blob = this.file.slice(slice.offset, slice.offset + slice.length);\n      const reader = new FileReader();\n      reader.onload = (event) => resolve(event.target.result);\n      reader.onerror = reject;\n      reader.onabort = reject;\n      reader.readAsArrayBuffer(blob);\n\n      if (signal) {\n        signal.addEventListener('abort', () => reader.abort());\n      }\n    });\n  }\n}\n\n/**\n * Create a new source from a given file/blob.\n * @param {Blob} file The file or blob to read from.\n * @returns The constructed source\n */\nexport function makeFileReaderSource(file) {\n  return new FileReaderSource(file);\n}\n","/** @module geotiff */\nimport GeoTIFFImage from './geotiffimage.js';\nimport DataView64 from './dataview64.js';\nimport DataSlice from './dataslice.js';\nimport Pool from './pool.js';\n\nimport { makeRemoteSource, makeCustomSource } from './source/remote.js';\nimport { makeBufferSource } from './source/arraybuffer.js';\nimport { makeFileReaderSource } from './source/filereader.js';\nimport { makeFileSource } from './source/file.js';\nimport { BaseClient, BaseResponse } from './source/client/base.js';\n\nimport { fieldTypes, fieldTagNames, arrayFields, geoKeyNames } from './globals.js';\nimport { writeGeotiff } from './geotiffwriter.js';\nimport * as globals from './globals.js';\nimport * as rgb from './rgb.js';\nimport { getDecoder, addDecoder } from './compression/index.js';\nimport { setLogger } from './logging.js';\n\nexport { globals };\nexport { rgb };\nexport { default as BaseDecoder } from './compression/basedecoder.js';\nexport { getDecoder, addDecoder };\nexport { setLogger };\n\n/**\n * @typedef {Uint8Array | Int8Array | Uint16Array | Int16Array | Uint32Array | Int32Array | Float32Array | Float64Array}\n * TypedArray\n */\n\n/**\n * @typedef {{ height:number, width: number }} Dimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray & { height: number; width: number}`\n * @typedef {TypedArray & Dimensions} TypedArrayWithDimensions\n */\n\n/**\n * The autogenerated docs are a little confusing here. The effective type is:\n *\n * `TypedArray[] & { height: number; width: number}`\n * @typedef {TypedArray[] & Dimensions} TypedArrayArrayWithDimensions\n */\n\n/**\n *  The autogenerated docs are a little confusing here. The effective type is:\n *\n * `(TypedArray | TypedArray[]) & { height: number; width: number}`\n * @typedef {TypedArrayWithDimensions | TypedArrayArrayWithDimensions} ReadRasterResult\n */\n\nfunction getFieldTypeLength(fieldType) {\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.SBYTE: case fieldTypes.UNDEFINED:\n      return 1;\n    case fieldTypes.SHORT: case fieldTypes.SSHORT:\n      return 2;\n    case fieldTypes.LONG: case fieldTypes.SLONG: case fieldTypes.FLOAT: case fieldTypes.IFD:\n      return 4;\n    case fieldTypes.RATIONAL: case fieldTypes.SRATIONAL: case fieldTypes.DOUBLE:\n    case fieldTypes.LONG8: case fieldTypes.SLONG8: case fieldTypes.IFD8:\n      return 8;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n}\n\nfunction parseGeoKeyDirectory(fileDirectory) {\n  const rawGeoKeyDirectory = fileDirectory.GeoKeyDirectory;\n  if (!rawGeoKeyDirectory) {\n    return null;\n  }\n\n  const geoKeyDirectory = {};\n  for (let i = 4; i <= rawGeoKeyDirectory[3] * 4; i += 4) {\n    const key = geoKeyNames[rawGeoKeyDirectory[i]];\n    const location = (rawGeoKeyDirectory[i + 1])\n      ? (fieldTagNames[rawGeoKeyDirectory[i + 1]]) : null;\n    const count = rawGeoKeyDirectory[i + 2];\n    const offset = rawGeoKeyDirectory[i + 3];\n\n    let value = null;\n    if (!location) {\n      value = offset;\n    } else {\n      value = fileDirectory[location];\n      if (typeof value === 'undefined' || value === null) {\n        throw new Error(`Could not get value of geoKey '${key}'.`);\n      } else if (typeof value === 'string') {\n        value = value.substring(offset, offset + count - 1);\n      } else if (value.subarray) {\n        value = value.subarray(offset, offset + count);\n        if (count === 1) {\n          value = value[0];\n        }\n      }\n    }\n    geoKeyDirectory[key] = value;\n  }\n  return geoKeyDirectory;\n}\n\nfunction getValues(dataSlice, fieldType, count, offset) {\n  let values = null;\n  let readMethod = null;\n  const fieldTypeLength = getFieldTypeLength(fieldType);\n\n  switch (fieldType) {\n    case fieldTypes.BYTE: case fieldTypes.ASCII: case fieldTypes.UNDEFINED:\n      values = new Uint8Array(count); readMethod = dataSlice.readUint8;\n      break;\n    case fieldTypes.SBYTE:\n      values = new Int8Array(count); readMethod = dataSlice.readInt8;\n      break;\n    case fieldTypes.SHORT:\n      values = new Uint16Array(count); readMethod = dataSlice.readUint16;\n      break;\n    case fieldTypes.SSHORT:\n      values = new Int16Array(count); readMethod = dataSlice.readInt16;\n      break;\n    case fieldTypes.LONG: case fieldTypes.IFD:\n      values = new Uint32Array(count); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SLONG:\n      values = new Int32Array(count); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.LONG8: case fieldTypes.IFD8:\n      values = new Array(count); readMethod = dataSlice.readUint64;\n      break;\n    case fieldTypes.SLONG8:\n      values = new Array(count); readMethod = dataSlice.readInt64;\n      break;\n    case fieldTypes.RATIONAL:\n      values = new Uint32Array(count * 2); readMethod = dataSlice.readUint32;\n      break;\n    case fieldTypes.SRATIONAL:\n      values = new Int32Array(count * 2); readMethod = dataSlice.readInt32;\n      break;\n    case fieldTypes.FLOAT:\n      values = new Float32Array(count); readMethod = dataSlice.readFloat32;\n      break;\n    case fieldTypes.DOUBLE:\n      values = new Float64Array(count); readMethod = dataSlice.readFloat64;\n      break;\n    default:\n      throw new RangeError(`Invalid field type: ${fieldType}`);\n  }\n\n  // normal fields\n  if (!(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n    for (let i = 0; i < count; ++i) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n    }\n  } else { // RATIONAL or SRATIONAL\n    for (let i = 0; i < count; i += 2) {\n      values[i] = readMethod.call(\n        dataSlice, offset + (i * fieldTypeLength),\n      );\n      values[i + 1] = readMethod.call(\n        dataSlice, offset + ((i * fieldTypeLength) + 4),\n      );\n    }\n  }\n\n  if (fieldType === fieldTypes.ASCII) {\n    return new TextDecoder('utf-8').decode(values);\n  }\n  return values;\n}\n\n/**\n * Data class to store the parsed file directory, geo key directory and\n * offset to the next IFD\n */\nclass ImageFileDirectory {\n  constructor(fileDirectory, geoKeyDirectory, nextIFDByteOffset) {\n    this.fileDirectory = fileDirectory;\n    this.geoKeyDirectory = geoKeyDirectory;\n    this.nextIFDByteOffset = nextIFDByteOffset;\n  }\n}\n\n/**\n * Error class for cases when an IFD index was requested, that does not exist\n * in the file.\n */\nclass GeoTIFFImageIndexError extends Error {\n  constructor(index) {\n    super(`No image at index ${index}`);\n    this.index = index;\n  }\n}\n\nclass GeoTIFFBase {\n  /**\n   * (experimental) Reads raster data from the best fitting image. This function uses\n   * the image with the lowest resolution that is still a higher resolution than the\n   * requested resolution.\n   * When specified, the `bbox` option is translated to the `window` option and the\n   * `resX` and `resY` to `width` and `height` respectively.\n   * Then, the [readRasters]{@link GeoTIFFImage#readRasters} method of the selected\n   * image is called and the result returned.\n   * @see GeoTIFFImage.readRasters\n   * @param {import('./geotiffimage').ReadRasterOptions} [options={}] optional parameters\n   * @returns {Promise<ReadRasterResult>} the decoded array(s), with `height` and `width`, as a promise\n   */\n  async readRasters(options = {}) {\n    const { window: imageWindow, width, height } = options;\n    let { resX, resY, bbox } = options;\n\n    const firstImage = await this.getImage();\n    let usedImage = firstImage;\n    const imageCount = await this.getImageCount();\n    const imgBBox = firstImage.getBoundingBox();\n\n    if (imageWindow && bbox) {\n      throw new Error('Both \"bbox\" and \"window\" passed.');\n    }\n\n    // if width/height is passed, transform it to resolution\n    if (width || height) {\n      // if we have an image window (pixel coordinates), transform it to a BBox\n      // using the origin/resolution of the first image.\n      if (imageWindow) {\n        const [oX, oY] = firstImage.getOrigin();\n        const [rX, rY] = firstImage.getResolution();\n\n        bbox = [\n          oX + (imageWindow[0] * rX),\n          oY + (imageWindow[1] * rY),\n          oX + (imageWindow[2] * rX),\n          oY + (imageWindow[3] * rY),\n        ];\n      }\n\n      // if we have a bbox (or calculated one)\n\n      const usedBBox = bbox || imgBBox;\n\n      if (width) {\n        if (resX) {\n          throw new Error('Both width and resX passed');\n        }\n        resX = (usedBBox[2] - usedBBox[0]) / width;\n      }\n      if (height) {\n        if (resY) {\n          throw new Error('Both width and resY passed');\n        }\n        resY = (usedBBox[3] - usedBBox[1]) / height;\n      }\n    }\n\n    // if resolution is set or calculated, try to get the image with the worst acceptable resolution\n    if (resX || resY) {\n      const allImages = [];\n      for (let i = 0; i < imageCount; ++i) {\n        const image = await this.getImage(i);\n        const { SubfileType: subfileType, NewSubfileType: newSubfileType } = image.fileDirectory;\n        if (i === 0 || subfileType === 2 || newSubfileType & 1) {\n          allImages.push(image);\n        }\n      }\n\n      allImages.sort((a, b) => a.getWidth() - b.getWidth());\n      for (let i = 0; i < allImages.length; ++i) {\n        const image = allImages[i];\n        const imgResX = (imgBBox[2] - imgBBox[0]) / image.getWidth();\n        const imgResY = (imgBBox[3] - imgBBox[1]) / image.getHeight();\n\n        usedImage = image;\n        if ((resX && resX > imgResX) || (resY && resY > imgResY)) {\n          break;\n        }\n      }\n    }\n\n    let wnd = imageWindow;\n    if (bbox) {\n      const [oX, oY] = firstImage.getOrigin();\n      const [imageResX, imageResY] = usedImage.getResolution(firstImage);\n\n      wnd = [\n        Math.round((bbox[0] - oX) / imageResX),\n        Math.round((bbox[1] - oY) / imageResY),\n        Math.round((bbox[2] - oX) / imageResX),\n        Math.round((bbox[3] - oY) / imageResY),\n      ];\n      wnd = [\n        Math.min(wnd[0], wnd[2]),\n        Math.min(wnd[1], wnd[3]),\n        Math.max(wnd[0], wnd[2]),\n        Math.max(wnd[1], wnd[3]),\n      ];\n    }\n\n    return usedImage.readRasters({ ...options, window: wnd });\n  }\n}\n\n/**\n * @typedef {Object} GeoTIFFOptions\n * @property {boolean} [cache=false] whether or not decoded tiles shall be cached.\n */\n\n/**\n * The abstraction for a whole GeoTIFF file.\n * @augments GeoTIFFBase\n */\nclass GeoTIFF extends GeoTIFFBase {\n  /**\n   * @constructor\n   * @param {*} source The datasource to read from.\n   * @param {boolean} littleEndian Whether the image uses little endian.\n   * @param {boolean} bigTiff Whether the image uses bigTIFF conventions.\n   * @param {number} firstIFDOffset The numeric byte-offset from the start of the image\n   *                                to the first IFD.\n   * @param {GeoTIFFOptions} [options] further options.\n   */\n  constructor(source, littleEndian, bigTiff, firstIFDOffset, options = {}) {\n    super();\n    this.source = source;\n    this.littleEndian = littleEndian;\n    this.bigTiff = bigTiff;\n    this.firstIFDOffset = firstIFDOffset;\n    this.cache = options.cache || false;\n    this.ifdRequests = [];\n    this.ghostValues = null;\n  }\n\n  async getSlice(offset, size) {\n    const fallbackSize = this.bigTiff ? 4048 : 1024;\n    return new DataSlice(\n      (await this.source.fetch([{\n        offset,\n        length: typeof size !== 'undefined' ? size : fallbackSize,\n      }]))[0],\n      offset,\n      this.littleEndian,\n      this.bigTiff,\n    );\n  }\n\n  /**\n   * Instructs to parse an image file directory at the given file offset.\n   * As there is no way to ensure that a location is indeed the start of an IFD,\n   * this function must be called with caution (e.g only using the IFD offsets from\n   * the headers or other IFDs).\n   * @param {number} offset the offset to parse the IFD at\n   * @returns {Promise<ImageFileDirectory>} the parsed IFD\n   */\n  async parseFileDirectoryAt(offset) {\n    const entrySize = this.bigTiff ? 20 : 12;\n    const offsetSize = this.bigTiff ? 8 : 2;\n\n    let dataSlice = await this.getSlice(offset);\n    const numDirEntries = this.bigTiff\n      ? dataSlice.readUint64(offset)\n      : dataSlice.readUint16(offset);\n\n    // if the slice does not cover the whole IFD, request a bigger slice, where the\n    // whole IFD fits: num of entries + n x tag length + offset to next IFD\n    const byteSize = (numDirEntries * entrySize) + (this.bigTiff ? 16 : 6);\n    if (!dataSlice.covers(offset, byteSize)) {\n      dataSlice = await this.getSlice(offset, byteSize);\n    }\n\n    const fileDirectory = {};\n\n    // loop over the IFD and create a file directory object\n    let i = offset + (this.bigTiff ? 8 : 2);\n    for (let entryCount = 0; entryCount < numDirEntries; i += entrySize, ++entryCount) {\n      const fieldTag = dataSlice.readUint16(i);\n      const fieldType = dataSlice.readUint16(i + 2);\n      const typeCount = this.bigTiff\n        ? dataSlice.readUint64(i + 4)\n        : dataSlice.readUint32(i + 4);\n\n      let fieldValues;\n      let value;\n      const fieldTypeLength = getFieldTypeLength(fieldType);\n      const valueOffset = i + (this.bigTiff ? 12 : 8);\n\n      // check whether the value is directly encoded in the tag or refers to a\n      // different external byte range\n      if (fieldTypeLength * typeCount <= (this.bigTiff ? 8 : 4)) {\n        fieldValues = getValues(dataSlice, fieldType, typeCount, valueOffset);\n      } else {\n        // resolve the reference to the actual byte range\n        const actualOffset = dataSlice.readOffset(valueOffset);\n        const length = getFieldTypeLength(fieldType) * typeCount;\n\n        // check, whether we actually cover the referenced byte range; if not,\n        // request a new slice of bytes to read from it\n        if (dataSlice.covers(actualOffset, length)) {\n          fieldValues = getValues(dataSlice, fieldType, typeCount, actualOffset);\n        } else {\n          const fieldDataSlice = await this.getSlice(actualOffset, length);\n          fieldValues = getValues(fieldDataSlice, fieldType, typeCount, actualOffset);\n        }\n      }\n\n      // unpack single values from the array\n      if (typeCount === 1 && arrayFields.indexOf(fieldTag) === -1\n        && !(fieldType === fieldTypes.RATIONAL || fieldType === fieldTypes.SRATIONAL)) {\n        value = fieldValues[0];\n      } else {\n        value = fieldValues;\n      }\n\n      // write the tags value to the file directly\n      fileDirectory[fieldTagNames[fieldTag]] = value;\n    }\n    const geoKeyDirectory = parseGeoKeyDirectory(fileDirectory);\n    const nextIFDByteOffset = dataSlice.readOffset(\n      offset + offsetSize + (entrySize * numDirEntries),\n    );\n\n    return new ImageFileDirectory(\n      fileDirectory,\n      geoKeyDirectory,\n      nextIFDByteOffset,\n    );\n  }\n\n  async requestIFD(index) {\n    // see if we already have that IFD index requested.\n    if (this.ifdRequests[index]) {\n      // attach to an already requested IFD\n      return this.ifdRequests[index];\n    } else if (index === 0) {\n      // special case for index 0\n      this.ifdRequests[index] = this.parseFileDirectoryAt(this.firstIFDOffset);\n      return this.ifdRequests[index];\n    } else if (!this.ifdRequests[index - 1]) {\n      // if the previous IFD was not yet loaded, load that one first\n      // this is the recursive call.\n      try {\n        this.ifdRequests[index - 1] = this.requestIFD(index - 1);\n      } catch (e) {\n        // if the previous one already was an index error, rethrow\n        // with the current index\n        if (e instanceof GeoTIFFImageIndexError) {\n          throw new GeoTIFFImageIndexError(index);\n        }\n        // rethrow anything else\n        throw e;\n      }\n    }\n    // if the previous IFD was loaded, we can finally fetch the one we are interested in.\n    // we need to wrap this in an IIFE, otherwise this.ifdRequests[index] would be delayed\n    this.ifdRequests[index] = (async () => {\n      const previousIfd = await this.ifdRequests[index - 1];\n      if (previousIfd.nextIFDByteOffset === 0) {\n        throw new GeoTIFFImageIndexError(index);\n      }\n      return this.parseFileDirectoryAt(previousIfd.nextIFDByteOffset);\n    })();\n    return this.ifdRequests[index];\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    const ifd = await this.requestIFD(index);\n    return new GeoTIFFImage(\n      ifd.fileDirectory, ifd.geoKeyDirectory,\n      this.dataView, this.littleEndian, this.cache, this.source,\n    );\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    let index = 0;\n    // loop until we run out of IFDs\n    let hasNext = true;\n    while (hasNext) {\n      try {\n        await this.requestIFD(index);\n        ++index;\n      } catch (e) {\n        if (e instanceof GeoTIFFImageIndexError) {\n          hasNext = false;\n        } else {\n          throw e;\n        }\n      }\n    }\n    return index;\n  }\n\n  /**\n   * Get the values of the COG ghost area as a parsed map.\n   * See https://gdal.org/drivers/raster/cog.html#header-ghost-area for reference\n   * @returns {Promise<Object>} the parsed ghost area or null, if no such area was found\n   */\n  async getGhostValues() {\n    const offset = this.bigTiff ? 16 : 8;\n    if (this.ghostValues) {\n      return this.ghostValues;\n    }\n    const detectionString = 'GDAL_STRUCTURAL_METADATA_SIZE=';\n    const heuristicAreaSize = detectionString.length + 100;\n    let slice = await this.getSlice(offset, heuristicAreaSize);\n    if (detectionString === getValues(slice, fieldTypes.ASCII, detectionString.length, offset)) {\n      const valuesString = getValues(slice, fieldTypes.ASCII, heuristicAreaSize, offset);\n      const firstLine = valuesString.split('\\n')[0];\n      const metadataSize = Number(firstLine.split('=')[1].split(' ')[0]) + firstLine.length;\n      if (metadataSize > heuristicAreaSize) {\n        slice = await this.getSlice(offset, metadataSize);\n      }\n      const fullString = getValues(slice, fieldTypes.ASCII, metadataSize, offset);\n      this.ghostValues = {};\n      fullString\n        .split('\\n')\n        .filter((line) => line.length > 0)\n        .map((line) => line.split('='))\n        .forEach(([key, value]) => {\n          this.ghostValues[key] = value;\n        });\n    }\n    return this.ghostValues;\n  }\n\n  /**\n   * Parse a (Geo)TIFF file from the given source.\n   *\n   * @param {*} source The source of data to parse from.\n   * @param {GeoTIFFOptions} [options] Additional options.\n   * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n   *                               to be aborted\n   */\n  static async fromSource(source, options, signal) {\n    const headerData = (await source.fetch([{ offset: 0, length: 1024 }], signal))[0];\n    const dataView = new DataView64(headerData);\n\n    const BOM = dataView.getUint16(0, 0);\n    let littleEndian;\n    if (BOM === 0x4949) {\n      littleEndian = true;\n    } else if (BOM === 0x4D4D) {\n      littleEndian = false;\n    } else {\n      throw new TypeError('Invalid byte order value.');\n    }\n\n    const magicNumber = dataView.getUint16(2, littleEndian);\n    let bigTiff;\n    if (magicNumber === 42) {\n      bigTiff = false;\n    } else if (magicNumber === 43) {\n      bigTiff = true;\n      const offsetByteSize = dataView.getUint16(4, littleEndian);\n      if (offsetByteSize !== 8) {\n        throw new Error('Unsupported offset byte-size.');\n      }\n    } else {\n      throw new TypeError('Invalid magic number.');\n    }\n\n    const firstIFDOffset = bigTiff\n      ? dataView.getUint64(8, littleEndian)\n      : dataView.getUint32(4, littleEndian);\n    return new GeoTIFF(source, littleEndian, bigTiff, firstIFDOffset, options);\n  }\n\n  /**\n   * Closes the underlying file buffer\n   * N.B. After the GeoTIFF has been completely processed it needs\n   * to be closed but only if it has been constructed from a file.\n   */\n  close() {\n    if (typeof this.source.close === 'function') {\n      return this.source.close();\n    }\n    return false;\n  }\n}\n\nexport { GeoTIFF };\nexport default GeoTIFF;\n\n/**\n * Wrapper for GeoTIFF files that have external overviews.\n * @augments GeoTIFFBase\n */\nclass MultiGeoTIFF extends GeoTIFFBase {\n  /**\n   * Construct a new MultiGeoTIFF from a main and several overview files.\n   * @param {GeoTIFF} mainFile The main GeoTIFF file.\n   * @param {GeoTIFF[]} overviewFiles An array of overview files.\n   */\n  constructor(mainFile, overviewFiles) {\n    super();\n    this.mainFile = mainFile;\n    this.overviewFiles = overviewFiles;\n    this.imageFiles = [mainFile].concat(overviewFiles);\n\n    this.fileDirectoriesPerFile = null;\n    this.fileDirectoriesPerFileParsing = null;\n    this.imageCount = null;\n  }\n\n  async parseFileDirectoriesPerFile() {\n    const requests = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)]\n      .concat(this.overviewFiles.map((file) => file.parseFileDirectoryAt(file.firstIFDOffset)));\n\n    this.fileDirectoriesPerFile = await Promise.all(requests);\n    return this.fileDirectoriesPerFile;\n  }\n\n  /**\n   * Get the n-th internal subfile of an image. By default, the first is returned.\n   *\n   * @param {number} [index=0] the index of the image to return.\n   * @returns {Promise<GeoTIFFImage>} the image at the given index\n   */\n  async getImage(index = 0) {\n    await this.getImageCount();\n    await this.parseFileDirectoriesPerFile();\n    let visited = 0;\n    let relativeIndex = 0;\n    for (let i = 0; i < this.imageFiles.length; i++) {\n      const imageFile = this.imageFiles[i];\n      for (let ii = 0; ii < this.imageCounts[i]; ii++) {\n        if (index === visited) {\n          const ifd = await imageFile.requestIFD(relativeIndex);\n          return new GeoTIFFImage(\n            ifd.fileDirectory, ifd.geoKeyDirectory,\n            imageFile.dataView, imageFile.littleEndian, imageFile.cache, imageFile.source,\n          );\n        }\n        visited++;\n        relativeIndex++;\n      }\n      relativeIndex = 0;\n    }\n\n    throw new RangeError('Invalid image index');\n  }\n\n  /**\n   * Returns the count of the internal subfiles.\n   *\n   * @returns {Promise<number>} the number of internal subfile images\n   */\n  async getImageCount() {\n    if (this.imageCount !== null) {\n      return this.imageCount;\n    }\n    const requests = [this.mainFile.getImageCount()]\n      .concat(this.overviewFiles.map((file) => file.getImageCount()));\n    this.imageCounts = await Promise.all(requests);\n    this.imageCount = this.imageCounts.reduce((count, ifds) => count + ifds, 0);\n    return this.imageCount;\n  }\n}\n\nexport { MultiGeoTIFF };\n\n/**\n * Creates a new GeoTIFF from a remote URL.\n * @param {string} url The URL to access the image from\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromUrl(url, options = {}, signal) {\n  return GeoTIFF.fromSource(makeRemoteSource(url, options), signal);\n}\n\n/**\n * Creates a new GeoTIFF from a custom {@link BaseClient}.\n * @param {BaseClient} client The client.\n * @param {object} [options] Additional options to pass to the source.\n *                           See {@link makeRemoteSource} for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromCustomClient(client, options = {}, signal) {\n  return GeoTIFF.fromSource(makeCustomSource(client, options), signal);\n}\n\n/**\n * Construct a new GeoTIFF from an\n * [ArrayBuffer]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer}.\n * @param {ArrayBuffer} arrayBuffer The data to read the file from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromArrayBuffer(arrayBuffer, signal) {\n  return GeoTIFF.fromSource(makeBufferSource(arrayBuffer), signal);\n}\n\n/**\n * Construct a GeoTIFF from a local file path. This uses the node\n * [filesystem API]{@link https://nodejs.org/api/fs.html} and is\n * not available on browsers.\n *\n * N.B. After the GeoTIFF has been completely processed it needs\n * to be closed but only if it has been constructed from a file.\n * @param {string} path The file path to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromFile(path, signal) {\n  return GeoTIFF.fromSource(makeFileSource(path), signal);\n}\n\n/**\n * Construct a GeoTIFF from an HTML\n * [Blob]{@link https://developer.mozilla.org/en-US/docs/Web/API/Blob} or\n * [File]{@link https://developer.mozilla.org/en-US/docs/Web/API/File}\n * object.\n * @param {Blob|File} blob The Blob or File object to read from.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<GeoTIFF>} The resulting GeoTIFF file.\n */\nexport async function fromBlob(blob, signal) {\n  return GeoTIFF.fromSource(makeFileReaderSource(blob), signal);\n}\n\n/**\n * Construct a MultiGeoTIFF from the given URLs.\n * @param {string} mainUrl The URL for the main file.\n * @param {string[]} overviewUrls An array of URLs for the overview images.\n * @param {Object} [options] Additional options to pass to the source.\n *                           See [makeRemoteSource]{@link module:source.makeRemoteSource}\n *                           for details.\n * @param {AbortSignal} [signal] An AbortSignal that may be signalled if the request is\n *                               to be aborted\n * @returns {Promise<MultiGeoTIFF>} The resulting MultiGeoTIFF file.\n */\nexport async function fromUrls(mainUrl, overviewUrls = [], options = {}, signal) {\n  const mainFile = await GeoTIFF.fromSource(makeRemoteSource(mainUrl, options), signal);\n  const overviewFiles = await Promise.all(\n    overviewUrls.map((url) => GeoTIFF.fromSource(makeRemoteSource(url, options))),\n  );\n\n  return new MultiGeoTIFF(mainFile, overviewFiles);\n}\n\n/**\n * Main creating function for GeoTIFF files.\n * @param {(Array)} array of pixel values\n * @returns {metadata} metadata\n */\nexport function writeArrayBuffer(values, metadata) {\n  return writeGeotiff(values, metadata);\n}\n\nexport { Pool };\nexport { GeoTIFFImage };\nexport { BaseClient, BaseResponse };\n","export class DeferredPromise {\n\tconstructor() {\n\t\tthis.promise = new Promise((resolve, reject) => {\n\t\t\tthis.reject = reject;\n\t\t\tthis.resolve = resolve;\n\t\t});\n\t}\n}","/**\n * PerkinElmer Vectra QPTIFF Reader\n *\n * This module provides a parser to organize pages of a PerkinElmer Vectra QPTIFF\n * file into their respective channels.\n *\n * OME Docs\n * https://docs.openmicroscopy.org/bio-formats/6.5.1/formats/perkinelmer-vectra-qptiff.html\n *\n * Download link for QPTIFF spec\n * https://downloads.openmicroscopy.org/images/Vectra-QPTIFF/perkinelmer/PKI_Image%20Format.docx\n */\n\n/**\n * Parse QPTIFF channels\n *\n * @param images {GeoTIFFImage[]} - Array of GeoTIFFImage objects\n * @returns {Map<string, {name: string, color: number[], images: GeoTIFFImage[]}>}\n *\n * @example\n * Map(2) {\n *  \"DAPI\" => {\n *    \"name\": \"DAPI\",\n *    \"color\": [0, 0, 255],\n *    \"images\": [GeoTIFFImage, GeoTIFFImage, ...]\n *   },\n *   \"Opal 570\" => {\n *    \"name\": \"Opal 570\",\n *    \"color\": [255, 255, 0],\n *    \"images\": [GeoTIFFImage, GeoTIFFImage, ...]\n *   }\n * }\n */\nexport const parsePerkinElmerChannels = (images) => {\n  const channels = new Map();\n\n  for (const image of images) {\n    const imageDescription = new DOMParser().parseFromString(\n      image.fileDirectory?.[\"ImageDescription\"],\n      \"text/xml\"\n    );\n\n    const channelName = imageDescription?.querySelector(\"Name\")?.textContent;\n    const channelColor = imageDescription?.querySelector(\"Color\")?.textContent;\n\n    if (!channelName) {\n      continue;\n    }\n\n    const channelRGB = channelColor\n      ? channelColor.split(\",\").map((v) => parseInt(v))\n      : [255, 255, 255];\n\n    if (!channels.has(channelName)) {\n      channels.set(channelName, {\n        name: channelName,\n        color: channelRGB,\n        images: [],\n      });\n    }\n\n    channels.get(channelName).images.push(image);\n  }\n\n  return channels;\n};\n","// The Converters class is adapted from https://github.com/geotiffjs/geotiff.js/blob/master/src/rgb.js\n// The MIT License (MIT)\n\n// Copyright (c) 2015 EOX IT Services GmbH\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\nexport class Converters {\n  static RGBAfromYCbCr(input) {\n    const rgbaRaster = new Uint8ClampedArray((input.length * 4) / 3);\n    let i, j;\n    for (i = 0, j = 0; i < input.length; i += 3, j += 4) {\n      const y = input[i];\n      const cb = input[i + 1];\n      const cr = input[i + 2];\n\n      rgbaRaster[j] = y + 1.402 * (cr - 0x80);\n      rgbaRaster[j + 1] = y - 0.34414 * (cb - 0x80) - 0.71414 * (cr - 0x80);\n      rgbaRaster[j + 2] = y + 1.772 * (cb - 0x80);\n      rgbaRaster[j + 3] = 255;\n    }\n    return rgbaRaster;\n  }\n\n  static RGBAfromRGB(input) {\n    const rgbaRaster = new Uint8ClampedArray((input.length * 4) / 3);\n    let i, j;\n    for (i = 0, j = 0; i < input.length; i += 3, j += 4) {\n      rgbaRaster[j] = input[i];\n      rgbaRaster[j + 1] = input[i + 1];\n      rgbaRaster[j + 2] = input[i + 2];\n      rgbaRaster[j + 3] = 255;\n    }\n    return rgbaRaster;\n  }\n\n  static RGBAfromWhiteIsZero(input, max) {\n    const rgbaRaster = new Uint8ClampedArray(input.length * 4);\n    let value;\n    for (let i = 0, j = 0; i < input.length; ++i, j += 4) {\n      value = 256 - (input[i] / max) * 256;\n      rgbaRaster[j] = value;\n      rgbaRaster[j + 1] = value;\n      rgbaRaster[j + 2] = value;\n      rgbaRaster[j + 3] = 255;\n    }\n    return rgbaRaster;\n  }\n\n  static RGBAfromBlackIsZero(input, max) {\n    const rgbaRaster = new Uint8ClampedArray(input.length * 4);\n    let value;\n    for (let i = 0, j = 0; i < input.length; ++i, j += 4) {\n      value = (input[i] / max) * 256;\n      rgbaRaster[j] = value;\n      rgbaRaster[j + 1] = value;\n      rgbaRaster[j + 2] = value;\n      rgbaRaster[j + 3] = 255;\n    }\n    return rgbaRaster;\n  }\n\n  static RGBAfromPalette(input, colorMap) {\n    const rgbaRaster = new Uint8ClampedArray(input.length * 4);\n    const greenOffset = colorMap.length / 3;\n    const blueOffset = (colorMap.length / 3) * 2;\n    for (let i = 0, j = 0; i < input.length; ++i, j += 4) {\n      const mapIndex = input[i];\n      rgbaRaster[j] = (colorMap[mapIndex] / 65536) * 256;\n      rgbaRaster[j + 1] = (colorMap[mapIndex + greenOffset] / 65536) * 256;\n      rgbaRaster[j + 2] = (colorMap[mapIndex + blueOffset] / 65536) * 256;\n      rgbaRaster[j + 3] = 255;\n    }\n    return rgbaRaster;\n  }\n\n  static RGBAfromCMYK(input) {\n    const rgbaRaster = new Uint8ClampedArray(input.length);\n    for (let i = 0, j = 0; i < input.length; i += 4, j += 4) {\n      const c = input[i];\n      const m = input[i + 1];\n      const y = input[i + 2];\n      const k = input[i + 3];\n\n      rgbaRaster[j] = 255 * ((255 - c) / 256) * ((255 - k) / 256);\n      rgbaRaster[j + 1] = 255 * ((255 - m) / 256) * ((255 - k) / 256);\n      rgbaRaster[j + 2] = 255 * ((255 - y) / 256) * ((255 - k) / 256);\n      rgbaRaster[j + 3] = 255;\n    }\n    return rgbaRaster;\n  }\n\n  static RGBAfromCIELab(input) {\n    // from https://github.com/antimatter15/rgb-lab/blob/master/color.js\n    const Xn = 0.95047;\n    const Yn = 1.0;\n    const Zn = 1.08883;\n    const rgbaRaster = new Uint8ClampedArray((input.length * 4) / 3);\n\n    for (let i = 0, j = 0; i < input.length; i += 3, j += 4) {\n      const L = input[i + 0];\n      const a_ = (input[i + 1] << 24) >> 24; // conversion from uint8 to int8\n      const b_ = (input[i + 2] << 24) >> 24; // same\n\n      let y = (L + 16) / 116;\n      let x = a_ / 500 + y;\n      let z = y - b_ / 200;\n      let r;\n      let g;\n      let b;\n\n      x = Xn * (x * x * x > 0.008856 ? x * x * x : (x - 16 / 116) / 7.787);\n      y = Yn * (y * y * y > 0.008856 ? y * y * y : (y - 16 / 116) / 7.787);\n      z = Zn * (z * z * z > 0.008856 ? z * z * z : (z - 16 / 116) / 7.787);\n\n      r = x * 3.2406 + y * -1.5372 + z * -0.4986;\n      g = x * -0.9689 + y * 1.8758 + z * 0.0415;\n      b = x * 0.0557 + y * -0.204 + z * 1.057;\n\n      r = r > 0.0031308 ? 1.055 * r ** (1 / 2.4) - 0.055 : 12.92 * r;\n      g = g > 0.0031308 ? 1.055 * g ** (1 / 2.4) - 0.055 : 12.92 * g;\n      b = b > 0.0031308 ? 1.055 * b ** (1 / 2.4) - 0.055 : 12.92 * b;\n\n      rgbaRaster[j] = Math.max(0, Math.min(1, r)) * 255;\n      rgbaRaster[j + 1] = Math.max(0, Math.min(1, g)) * 255;\n      rgbaRaster[j + 2] = Math.max(0, Math.min(1, b)) * 255;\n      rgbaRaster[j + 3] = 255;\n    }\n    return rgbaRaster;\n  }\n}\n","/**\n * Patch Image Job for back compatibility with OpenSeadragon v3.0.0 and below\n */\n\nexport function patchOSDImageJob($) {\n  if (!$.version || $.version.major < 2 || ($.version.major == 2 && $.version.minor < 3)) {\n    console.error(\"This version of OpenSeadragon is too old to support this monkey patch\");\n    return;\n  }\n  if ($.ImageJob) {\n    //version > 3.1; the new mechanism for this is implemented in the prototype; no need to monkey patch\n    return;\n  }\n  function ImageJob(options) {\n    $.extend(\n      true,\n      this,\n      {\n        timeout: $.DEFAULT_SETTINGS.timeout,\n        jobId: null,\n      },\n      options\n    );\n\n    /**\n     * Image object which will contain downloaded image.\n     * @member {Image} image\n     * @memberof OpenSeadragon.ImageJob#\n     */\n    this.image = null;\n  }\n\n  ImageJob.prototype = {\n    errorMsg: null,\n\n    /**\n     * Starts the image job.\n     * @method\n     */\n    start: function () {\n      var self = this;\n      var selfAbort = this.abort;\n\n      this.image = new Image();\n\n      this.image.onload = function () {\n        self.finish(true);\n      };\n      this.image.onabort = this.image.onerror = function () {\n        self.errorMsg = \"Image load aborted\";\n        self.finish(false);\n      };\n\n      this.jobId = window.setTimeout(function () {\n        self.errorMsg = \"Image load exceeded timeout (\" + self.timeout + \" ms)\";\n        self.finish(false);\n      }, this.timeout);\n\n      // Load the tile with an AJAX request if the loadWithAjax option is\n      // set. Otherwise load the image by setting the source proprety of the image object.\n      if (this.loadWithAjax) {\n        this.request = $.makeAjaxRequest({\n          url: this.src,\n          withCredentials: this.ajaxWithCredentials,\n          headers: this.ajaxHeaders,\n          responseType: \"arraybuffer\",\n          postData: this.postData,\n          success: function (request) {\n            var blb;\n            // Make the raw data into a blob.\n            // BlobBuilder fallback adapted from\n            // http://stackoverflow.com/questions/15293694/blob-constructor-browser-compatibility\n            try {\n              blb = new window.Blob([request.response]);\n            } catch (e) {\n              var BlobBuilder =\n                window.BlobBuilder ||\n                window.WebKitBlobBuilder ||\n                window.MozBlobBuilder ||\n                window.MSBlobBuilder;\n              if (e.name === \"TypeError\" && BlobBuilder) {\n                var bb = new BlobBuilder();\n                bb.append(request.response);\n                blb = bb.getBlob();\n              }\n            }\n            // If the blob is empty for some reason consider the image load a failure.\n            if (blb.size === 0) {\n              self.errorMsg = \"Empty image response.\";\n              self.finish(false);\n            }\n            // Create a URL for the blob data and make it the source of the image object.\n            // This will still trigger Image.onload to indicate a successful tile load.\n            var url = (window.URL || window.webkitURL).createObjectURL(blb);\n            self.image.src = url;\n          },\n          error: function (request) {\n            self.errorMsg = \"Image load aborted - XHR error: Ajax returned \" + request.status;\n            self.finish(false);\n          },\n        });\n\n        // Provide a function to properly abort the request.\n        this.abort = function () {\n          self.request.abort();\n\n          // Call the existing abort function if available\n          if (typeof selfAbort === \"function\") {\n            selfAbort();\n          }\n        };\n      } else {\n        if (this.crossOriginPolicy !== false) {\n          this.image.crossOrigin = this.crossOriginPolicy;\n        }\n        if (this.src.fetch) {\n          this.src.fetch().then((src) => (this.image.src = src));\n        } else {\n          this.image.src = this.src;\n        }\n      }\n    },\n\n    finish: function (successful) {\n      this.image.onload = this.image.onerror = this.image.onabort = null;\n      if (!successful) {\n        this.image = null;\n      }\n\n      if (this.jobId) {\n        window.clearTimeout(this.jobId);\n      }\n\n      this.callback(this);\n    },\n  };\n  function completeJob(loader, job, callback) {\n    var nextJob;\n\n    loader.jobsInProgress--;\n\n    if (\n      (!loader.jobLimit || loader.jobsInProgress < loader.jobLimit) &&\n      loader.jobQueue.length > 0\n    ) {\n      nextJob = loader.jobQueue.shift();\n      nextJob.start();\n      loader.jobsInProgress++;\n    }\n\n    callback(job.image, job.errorMsg, job.request);\n  }\n  $.ImageLoader.prototype.addJob = function (options) {\n    var _this = this,\n      complete = function (job) {\n        completeJob(_this, job, options.callback);\n      },\n      jobOptions = {\n        src: options.src,\n        loadWithAjax: options.loadWithAjax,\n        ajaxHeaders: options.loadWithAjax ? options.ajaxHeaders : null,\n        crossOriginPolicy: options.crossOriginPolicy,\n        ajaxWithCredentials: options.ajaxWithCredentials,\n        postData: options.postData,\n        callback: complete,\n        abort: options.abort,\n        timeout: this.timeout,\n      },\n      newJob = new ImageJob(jobOptions);\n\n    if (!this.jobLimit || this.jobsInProgress < this.jobLimit) {\n      newJob.start();\n      this.jobsInProgress++;\n    } else {\n      this.jobQueue.push(newJob);\n    }\n  };\n  $.Tile.prototype._hasTransparencyChannel = function () {\n    return false;\n  };\n}\n","import { fromBlob, fromUrl, globals, Pool } from \"geotiff\";\nimport { DeferredPromise } from \"./utils/DeferredPromise.js\";\nimport { parsePerkinElmerChannels } from \"./formats/perkinElmer.js\";\nimport { Converters } from \"./utils/Converters.js\";\nimport { patchOSDImageJob } from \"./utils/osdMonkeyPatch.js\";\n\n/**\n * @class GeoTIFFTileSource\n * @memberof OpenSeadragon\n * @extends OpenSeadragon.TileSource\n * @param {File|String|Object} input A File object, url string, or object with fields for pre-loaded GeoTIFF and GeoTIFFImages objects\n * @param {Object} opts Options object. To do: how to document options fields?\n *                 opts.logLatency: print latency to fetch and process each tile to console.log or the provided function\n *                 opts.tileWidth: tileWidth to request at each level. Defaults to tileWidth specified by TIFF file or 256 if unspecified by the file\n *                 opts.tileHeight:tileWidth to request at each level. Defaults to tileWidth specified by TIFF file or 256 if unspecified by the file\n *\n * @property {Object} GeoTIFF The GeoTIFF.js representation of the underlying file. Undefined until the file is opened successfully\n * @property {Array}  GeoTIFFImages Array of GeoTIFFImage objects, each representing one layer. Undefined until the file is opened successfully\n * @property {Bool}   ready set to true once all promises have resolved\n * @property {Object} promises\n * @property {Number} dimensions\n * @property {Number} aspectRatio\n * @property {Number} tileOverlap\n * @property {Number} tileSize\n * @property {Array}  levels\n */\nexport class GeoTIFFTileSource{\n  /**\n   * Create a shared GeoTIFF Pool for all GeoTIFFTileSources to use.\n   *\n   * If a shared pool is not created, every page of every GeoTIFF will create its own pool,\n   * which can quickly lead to browser crashes.\n   *\n   * @static sharedPool\n   * @type {Pool}\n   */\n  static sharedPool = new Pool();\n  static _osdReady = false;\n\n  constructor(input, opts = { logLatency: false }) {\n    \n    if (!GeoTIFFTileSource._osdReady) {\n      GeoTIFFTileSource.applyOSDPatch(OpenSeadragon);\n    }\n\n    let self = this;\n\n    this.input = input;\n    this.options = opts;\n    this.channel = input?.channel ?? null;\n\n    this._ready = false;\n    this._pool = GeoTIFFTileSource.sharedPool;\n    this._tileSize = 256;\n\n    if (input.GeoTIFF && input.GeoTIFFImages) {\n      this.promises = {\n        GeoTIFF: Promise.resolve(input.GeoTIFF),\n        GeoTIFFImages: Promise.resolve(input.GeoTIFFImages),\n        ready: new DeferredPromise(),\n      };\n      this.GeoTIFF = input.GeoTIFF;\n      this.imageCount = input.GeoTIFFImages.length;\n      this.GeoTIFFImages = input.GeoTIFFImages;\n\n      this.setupLevels();\n    } else {\n      this.promises = {\n        GeoTIFF: input instanceof File ? fromBlob(input) : fromUrl(input),\n        GeoTIFFImages: new DeferredPromise(),\n        ready: new DeferredPromise(),\n      };\n      this.promises.GeoTIFF.then((tiff) => {\n        self.GeoTIFF = tiff;\n        return tiff.getImageCount();\n      })\n        .then((count) => {\n          self.imageCount = count;\n          let promises = [...Array(count).keys()].map((index) => self.GeoTIFF.getImage(index));\n          return Promise.all(promises);\n        })\n        .then((images) => {\n          self.GeoTIFFImages = images;\n          self.promises.GeoTIFFImages.resolve(images);\n          this.setupLevels();\n        })\n        .catch((error) => {\n          console.error(\"Re-throwing error with GeoTIFF:\", error);\n          throw error;\n        });\n    }\n  }\n\n  // Apply ImageJob patch to OpenSeadragon. Can be extended for modular patches.\n  static applyOSDPatch = (OpenSeadragon) => {\n    patchOSDImageJob(OpenSeadragon);\n\n    // Set flag to prevent re-applying the patch\n    GeoTIFFTileSource._osdReady = true;\n  };\n\n  static getAllTileSources = async (input, opts) => {\n    const fileExtension =\n      input instanceof File ? input.name.split(\".\").pop() : input.split(\".\").pop();\n\n    let tiff = input instanceof File ? fromBlob(input) : fromUrl(input);\n\n    return tiff\n      .then((t) => {\n        tiff = t;\n        return t.getImageCount();\n      })\n      .then((c) =>\n        Promise.all([...Array(c).keys()].map(async (index) => (await tiff).getImage(index)))\n      )\n      .then((images) => {\n        // Filter out images with photometricInterpretation.TransparencyMask\n        images = images.filter(\n          (image) =>\n            image.fileDirectory.photometricInterpretation !==\n            globals.photometricInterpretations.TransparencyMask\n        );\n\n        // Sort by width (largest first), then detect pyramids\n        images.sort((a, b) => b.getWidth() - a.getWidth());\n\n        // find unique aspect ratios (with tolerance to account for rounding)\n        const tolerance = 0.015;\n\n        const aspectRatioSets = images.reduce((accumulator, image) => {\n          const r = image.getWidth() / image.getHeight();\n          const exists = accumulator.filter((set) => Math.abs(1 - set.aspectRatio / r) < tolerance);\n          if (exists.length === 0) {\n            let set = {\n              aspectRatio: r,\n              images: [image],\n            };\n            accumulator.push(set);\n          } else {\n            exists[0].images.push(image);\n          }\n          return accumulator;\n        }, []);\n\n        const imageSets = aspectRatioSets.map((set) => set.images);\n\n        return imageSets.map((images, index) => {\n          // Check if QPTIFF\n          if (index !== 0) {\n            return new OpenSeadragon.GeoTIFFTileSource(\n              {\n                GeoTIFF: tiff,\n                GeoTIFFImages: images,\n              },\n              opts\n            );\n          }\n\n          switch (fileExtension) {\n            case \"qptiff\":\n              const channels = parsePerkinElmerChannels(images);\n              return Array.from(channels.values()).map((channel, index) => {\n                return new OpenSeadragon.GeoTIFFTileSource(\n                  {\n                    GeoTIFF: tiff,\n                    GeoTIFFImages: channel.images,\n                    channel: {\n                      name: channel.name,\n                      color: channel.color,\n                    },\n                  },\n                  opts\n                );\n              });\n\n            default:\n              return new OpenSeadragon.GeoTIFFTileSource(\n                {\n                  GeoTIFF: tiff,\n                  GeoTIFFImages: images,\n                },\n                opts\n              );\n          }\n        });\n      });\n  };\n\n  /**\n   * Return the tileWidth for a given level.\n   * @function\n   * @param {Number} level\n   */\n  getTileWidth = (level) => {\n    if (this.levels.length > level) {\n      return this.levels[level].tileWidth;\n    }\n  };\n\n  /**\n   * Return the tileHeight for a given level.\n   * @function\n   * @param {Number} level\n   */\n  getTileHeight = (level) => {\n    if (this.levels.length > level) {\n      return this.levels[level].tileHeight;\n    }\n  };\n\n  /**\n   * @function\n   * @param {Number} level\n   */\n  getLevelScale = (level) => {\n    let levelScale = NaN;\n    if (this.levels.length > 0 && level >= this.minLevel && level <= this.maxLevel) {\n      levelScale = this.levels[level].width / this.levels[this.maxLevel].width;\n    }\n    return levelScale;\n  };\n\n  /**\n   * Handle maintaining unique caches per channel in multi-channel images\n   */\n  getTileHashKey = (level, x, y) => {\n    return `${this?.channel?.name ?? \"\"}_${level}_${x}_${y}`;\n  };\n\n  /**\n   * Implement function here instead of as custom tile source in client code\n   * @function\n   * @param {Number} levelnum\n   * @param {Number} x\n   * @param {Number} y\n   */\n  getTileUrl = (levelnum, x, y) => {\n    // return dataURL from reading tile data from the GeoTIFF object as String object (for cache key) with attached promise\n    let level = this.levels[levelnum];\n    let url = new String(`${levelnum}/${x}_${y}`); // use new String() so that custom fields can be set (see url.fetch below)\n\n    url.fetch = (\n      (ts, level, x, y, src) => () =>\n        this.regionToDataUrl.call(ts, level, x, y, src)\n    )(this, level, x, y, url);\n\n    return url;\n  };\n\n  downloadTileStart = (context) => {\n    context.src.fetch().then((dataURL) => {\n      let image = new Image();\n      let request = \"\" + context.src;\n      image.onload = function () {\n        context.finish(image);\n      };\n      image.onerror = image.onabort = function () {\n        context.finish(null, request, \"Request aborted\");\n      };\n      image.src = dataURL;\n    });\n  };\n\n  downloadTileAbort = (context) => {\n    context.src.abortController && context.src.abortController.abort();\n  };\n\n  setupComplete = () => {\n    this._ready = true;\n    this.promises.ready.resolve();\n\n    this.raiseEvent(\"ready\", { tileSource: this });\n  };\n\n  setupLevels = () => {\n    if (this._ready) {\n      return;\n    }\n\n    let images = this.GeoTIFFImages.sort((a, b) => b.getWidth() - a.getWidth());\n\n    // default to 256x256 tiles, but defer to options passed in\n    let defaultTileWidth = this._tileSize;\n    let defaultTileHeight = this._tileSize;\n\n    // The first image is the highest-resolution view (at least, with the largest width)\n    let fullWidth = images[0].getWidth();\n    this.width = fullWidth;\n\n    let fullHeight = images[0].getHeight();\n    this.height = fullHeight;\n\n    this.tileOverlap = 0;\n    this.minLevel = 0;\n    this.aspectRatio = this.width / this.height;\n    this.dimensions = new OpenSeadragon.Point(this.width, this.height);\n\n    // a valid tiled pyramid has strictly monotonic size for levels\n    let pyramid = images.reduce(\n      (acc, im) => {\n        if (acc.width !== -1) {\n          acc.valid = acc.valid && im.getWidth() < acc.width; // ensure width monotonically decreases\n        }\n        acc.width = im.getWidth();\n        return acc;\n      },\n      { valid: true, width: -1 }\n    );\n\n    if (pyramid.valid) {\n      this.levels = images.map((image) => {\n        let w = image.getWidth();\n        let h = image.getHeight();\n\n        return {\n          width: w,\n          height: h,\n          tileWidth: this.options.tileWidth || image.getTileWidth() || defaultTileWidth,\n          tileHeight: this.options.tileHeight || image.getTileHeight() || defaultTileHeight,\n          image: image,\n          scaleFactor: 1,\n        };\n      });\n      this.maxLevel = this.levels.length - 1;\n    } else {\n      let numPowersOfTwo = Math.ceil(\n        Math.log2(Math.max(fullWidth / defaultTileWidth, fullHeight / defaultTileHeight))\n      );\n      let levelsToUse = [...Array(numPowersOfTwo).keys()].filter((v) => v % 2 == 0); //use every other power of two for scales in the \"pyramid\"\n\n      this.levels = levelsToUse\n        .map((levelnum) => {\n          let scale = Math.pow(2, levelnum);\n\n          const levelImages = images.filter((image) => {\n            const prevScale = Math.pow(2, levelnum - 1);\n            // All images with correct resolution\n            return prevScale >= 0\n              ? image.getWidth() * prevScale < fullWidth && image.getWidth() * scale >= fullWidth\n              : image.getWidth() * scale >= fullWidth;\n          });\n\n          if (levelImages.length === 0) {\n            return null;\n          }\n\n          const image = levelImages[0];\n\n          // let image = images.filter((im) => im.getWidth() * scale >= fullWidth).slice(-1)[0]; // smallest image with sufficient resolution\n          return {\n            width: fullWidth / scale,\n            height: fullHeight / scale,\n            tileWidth: this.options.tileWidth || image.getTileWidth() || defaultTileWidth,\n            tileHeight: this.options.tileHeight || image.getTileHeight() || defaultTileHeight,\n            image: image,\n            scaleFactor: (scale * image.getWidth()) / fullWidth,\n          };\n        })\n        .filter((level) => level !== null);\n      this.maxLevel = this.levels.length - 1;\n    }\n    this.levels = this.levels.sort((a, b) => a.width - b.width);\n\n    this._tileWidth = this.levels[0].tileWidth;\n    this._tileHeight = this.levels[0].tileHeight;\n\n    this.setupComplete();\n  };\n\n  regionToDataUrl = (level, x, y, src) => {\n    let startTime = this.options.logLatency && Date.now();\n    let abortController = (src.abortController = new AbortController()); // add abortController to the src object so OpenSeadragon can abort the request\n    let abortSignal = abortController.signal;\n\n    const width = level.tileWidth;\n    const height = level.tileHeight;\n\n    const window = [x * width, y * height, (x + 1) * width, (y + 1) * height].map(\n      (v) => v * level.scaleFactor\n    );\n\n    const image = level.image;\n    const isQPTIFF = image.fileDirectory?.[\"Software\"]?.startsWith(\"PerkinElmer-QPI\");\n\n    if (isQPTIFF) {\n      // Parse XML image description\n      const qptiffXML = new DOMParser().parseFromString(\n        image.fileDirectory?.[\"ImageDescription\"],\n        \"text/xml\"\n      );\n\n      // Get Name and Color tags\n      const channelName = qptiffXML.querySelector(\"Name\")?.textContent;\n      const channelColor = qptiffXML.querySelector(\"Color\")?.textContent;\n\n      const channelRGB = channelColor\n        ? channelColor.split(\",\").map((v) => parseInt(v))\n        : [255, 255, 255];\n\n      return level.image\n        .readRGB({\n          interleave: true,\n          window: window,\n          pool: this._pool,\n          width: level.tileWidth,\n          height: level.tileHeight,\n          signal: abortSignal,\n        })\n        .then((data) => {\n          // let dataURL = tileToDataUrl(data, level.tileWidth, level.tileHeight, startTime);\n          let canvas = document.createElement(\"canvas\");\n          canvas.width = level.tileWidth;\n          canvas.height = level.tileHeight;\n          let ctx = canvas.getContext(\"2d\");\n\n          let arr = new Uint8ClampedArray(4 * canvas.width * canvas.height);\n          let rgb = new Uint8ClampedArray(data);\n\n          let i, a;\n          for (i = 0, a = 0; i < rgb.length; i += 3, a += 4) {\n            arr[a] = (rgb[i] * channelRGB[0]) / 255;\n            arr[a + 1] = (rgb[i + 1] * channelRGB[1]) / 255;\n            arr[a + 2] = (rgb[i + 2] * channelRGB[2]) / 255;\n            arr[a + 3] = 255;\n          }\n\n          const imageData = ctx.createImageData(canvas.width, canvas.height);\n          imageData.data.set(arr);\n          ctx.putImageData(imageData, 0, 0);\n\n          let dataURL = canvas.toDataURL(\"image/jpeg\", 0.8);\n          this.options.logLatency &&\n            (typeof this.options.logLatency == \"function\" ? this.options.logLatency : console.log)(\n              \"Tile latency (ms):\",\n              Date.now() - startTime\n            );\n          return dataURL;\n        });\n    } else {\n      // Use getTileOrStrip followed by converters because it is noticeably more efficient than readRGB\n      return level.image.getTileOrStrip(x, y, null, this._pool, abortSignal).then((raster) => {\n        let data = new Uint8ClampedArray(raster.data);\n\n        let canvas = document.createElement(\"canvas\");\n        canvas.width = level.tileWidth;\n        canvas.height = level.tileHeight;\n        let ctx = canvas.getContext(\"2d\");\n\n        let photometricInterpretation = level.image.fileDirectory.PhotometricInterpretation;\n        let arr;\n\n        // If already in RGBA format, use it\n        if ((data.length / (canvas.width * canvas.height)) % 4 === 0) {\n          arr = data;\n        } else {\n          switch (photometricInterpretation) {\n            case globals.photometricInterpretations.WhiteIsZero: // grayscale, white is zero\n              arr = Converters.RGBAfromWhiteIsZero(\n                data,\n                2 ** level.image.fileDirectory.BitsPerSample[0]\n              );\n              break;\n            case globals.photometricInterpretations.BlackIsZero: // grayscale, white is zero\n              arr = Converters.RGBAfromBlackIsZero(\n                data,\n                2 ** level.image.fileDirectory.BitsPerSample[0]\n              );\n              break;\n            case globals.photometricInterpretations.RGB: // RGB\n              arr = Converters.RGBAfromRGB(data);\n              break;\n            case globals.photometricInterpretations.Palette: // colormap\n              arr = Converters.RGBAfromPalette(data, 2 ** level.image.fileDirectory.colorMap);\n              break;\n            case globals.photometricInterpretations.CMYK: // CMYK\n              arr = Converters.RGBAfromCMYK(data);\n              break;\n            case globals.photometricInterpretations.YCbCr: // YCbCr\n              arr = Converters.RGBAfromYCbCr(data);\n              break;\n            case globals.photometricInterpretations.CIELab: // CIELab\n              arr = Converters.RGBAfromCIELab(data);\n              break;\n          }\n        }\n\n        const imageData = ctx.createImageData(canvas.width, canvas.height);\n        imageData.data.set(arr);\n        ctx.putImageData(imageData, 0, 0);\n\n        let dataURL = canvas.toDataURL(\"image/jpeg\", 0.8);\n        this.options.logLatency &&\n          (typeof this.options.logLatency == \"function\" ? this.options.logLatency : console.log)(\n            \"Tile latency (ms):\",\n            Date.now() - startTime\n          );\n        return dataURL;\n      });\n    }\n  };\n}\n","import { GeoTIFFTileSource } from \"./GeoTIFFTileSource.js\";\n\n/**\n * Enable GeoTIFF Tile Source for OpenSeadragon.\n *\n * The GeoTIFFTileSource uses the GeoTIFF.js library to serve tiles from local file or a remote URL.\n * Remote files require HTTP range requests to be enabled on the server.\n *\n * @param {OpenSeadragon} OpenSeadragon - The OpenSeadragon class.\n */\nexport const enableGeoTIFFTileSource = (OpenSeadragon) => {\n  // Attach the class to the OpenSeadragon namespace\n  Object.assign(GeoTIFFTileSource.prototype, OpenSeadragon.TileSource.prototype, GeoTIFFTileSource.prototype);\n  OpenSeadragon.GeoTIFFTileSource = GeoTIFFTileSource;\n};\n\n// Run an IIFE to attach the GeoTIFFTileSource to the OpenSeadragon namespace\n// IF OpenSeadragon is available in the global scope\n(function (global, factory) {\n  // Skip if currently in ESM mode\n  if (typeof exports === \"undefined\") {\n    return;\n  }\n\n  // Check if OpenSeadragon is available\n  if (typeof global.OpenSeadragon !== \"undefined\") {\n    // Attach the GeoTIFFTileSource to the OpenSeadragon namespace\n    factory(global.OpenSeadragon);\n  }\n})(typeof window !== \"undefined\" ? window : this, enableGeoTIFFTileSource);\n\nexport { GeoTIFFTileSource };\n"],"names":["uncurryThis","target","thisArg","args","ReflectApply","uncurryThisGetter","key","ReflectGetOwnPropertyDescriptor","ReflectConstruct","ReflectDefineProperty","ReflectGet","ReflectGetPrototypeOf","ReflectHas","ReflectOwnKeys","ReflectSet","ReflectSetPrototypeOf","SymbolIterator","SymbolSpecies","SymbolToStringTag","SymbolFor","NativeObject","ObjectCreate","ObjectDefineProperty","ObjectFreeze","ObjectIs","NativeArray","ArrayPrototype","NativeArrayPrototypeSymbolIterator","ArrayPrototypeSymbolIterator","NativeArrayBuffer","ArrayBufferPrototype","NativeSharedArrayBuffer","TypedArray","TypedArrayPrototype","NativeUint8Array","NativeUint16Array","NativeUint32Array","NativeFloat32Array","ArrayIteratorPrototype","ArrayIteratorPrototypeNext","GeneratorPrototypeNext","IteratorPrototype","DataViewPrototype","DataViewPrototypeGetUint16","NativeWeakMap","WeakMapPrototype","WeakMapPrototypeGet","WeakMapPrototypeSet","arrayIterators","SafeIteratorPrototype","arrayIterator","safeIfNeeded","array","safe","generators","DummyArrayIteratorPrototype","generator","buffer","floatView","uint32View","baseTable","shiftTable","mantissaTable","m","e","exponentTable","offsetTable","convertToNumber","float16bits","i","getFloat16","dataView","byteOffset","opts","getAttribute","tag","attributeName","options","debug","xml","opening","quotechars","char","pattern","match","getAttributeModule","indexOfMatch","startIndex","indexOfMatchModule","indexOfMatchEnd","indexOfMatchEndModule","countSubstring","string","substring","countSubstringModule","require$$0","require$$1","require$$2","findTagByName","tagName","nested","start","afterStart","relativeEnd","selfClosing","openings","closings","clip","end","outer","inner","findTagByNameModule","findTagsByName","tags","findTagsByNameModule","fieldTagNames","fieldTags","arrayFields","fieldTypeNames","fieldTypes","photometricInterpretations","ExtraSamplesValues","LercParameters","LercAddCompression","geoKeyNames","fromWhiteIsZero","raster","max","width","height","rgbRaster","value","j","fromBlackIsZero","fromPalette","colorMap","greenOffset","blueOffset","mapIndex","fromCMYK","cmykRaster","c","y","k","fromYCbCr","yCbCrRaster","cb","cr","Xn","Yn","Zn","fromCIELab","cieLabRaster","L","a_","b_","x","z","r","g","b","registry","addDecoder","cases","importFn","getDecoder","fileDirectory","Decoder","copyNewSize","samplesPerPixel","resampleNearest","valueArrays","inWidth","inHeight","outWidth","outHeight","relX","relY","newArray","cy","cx","lerp","v0","v1","resampleBilinear","rawY","yl","yh","rawX","tx","xl","xh","ll","hl","lh","hh","resample","method","resampleNearestInterleaved","valueArray","samples","resampleBilinearInterleaved","resampleInterleaved","sum","s","arrayForType","format","bitsPerSample","size","needsNormalization","normalizeArray","inBuffer","planarConfiguration","tileWidth","tileHeight","view","outSize","samplesToTransfer","outArray","bitMask","pixelBitSkip","bitsPerLine","lineBitOffset","pixelBitOffset","bitOffset","outIndex","innerBitOffset","raw","GeoTIFFImage","geoKeys","littleEndian","cache","source","bytes","sampleIndex","offset","sample","poolOrDecoder","signal","numTilesPerRow","numTilesPerCol","index","tiles","byteCount","slice","request","data","sampleFormat","imageWindow","interleave","resampleMethod","imageWidth","imageHeight","minXTile","maxXTile","minYTile","maxYTile","windowWidth","bytesPerPixel","srcSampleOffsets","sampleReaders","promises","yTile","xTile","getPromise","si","promise","tile","blockHeight","firstLine","firstCol","lastLine","lastCol","reader","ymax","xmax","pixelOffset","windowCoordinate","resampled","wnd","pool","fillValue","imageWindowWidth","imageWindowHeight","numPixels","window","enableAlpha","pi","subOptions","red","green","blue","tiePoints","metadata","items","item","modelTransformation","referenceImage","modelPixelScale","refResX","refResY","refResZ","tilegrid","a","d","f","h","projected","I","J","xs","pt","ys","origin","resolution","x1","y1","x2","y2","DataView64","arrayBuffer","left","right","combined","isNegative","carrying","byte","DataSlice","sliceOffset","bigTiff","length","defaultPoolSize","Pool","createWorker","resolve","module","create","decoder","worker","candidate","id","onMessage","CRLFCRLF","itemsToObject","obj","parseHeaders","text","line","kv","str","parseContentType","rawContentType","type","rawParams","paramsItems","param","parseContentRange","rawContentRange","total","parseByteRanges","responseArrayBuffer","boundary","out","startBoundary","endBoundary","innerText","endOfHeaders","headers","startOfData","BaseSource","slices","QuickLRU","maxAge","expiry","deleted","newSize","removeCount","oldCacheSize","callbackFunction","thisArgument","wait","milliseconds","zip","A","B","AbortError","params","CustomAggregateError","errors","message","AggregateError","Block","BlockGroup","blockIds","BlockedSource","blockSize","cacheSize","blockId","block","blockRequests","missingBlockIds","allBlockIds","top","fileSize","firstBlockOffset","current","missingRequests","abortedBlockRequests","abortedBlockIds","blocks","failedBlocks","requiredBlocks","groups","groupRequests","groupIndex","group","response","blockOffset","o","t","err","sortedBlockIds","lastBlockId","blockIdLow","blockIdHigh","sliceData","sliceView","delta","topDelta","blockInnerOffset","rangeInnerOffset","usedBlockLength","blockView","BaseResponse","headerName","BaseClient","url","FetchResponse","name","FetchClient","credentials","XHRResponse","xhr","XHRClient","reject","fs","HttpResponse","dataPromise","HttpClient","urlMod","http","resolveData","chunks","chunk","RemoteSource","client","maxRanges","allowFullFile","byteRanges","first","others","maybeWrapInBlockedSource","makeFetchSource","blockOptions","makeXHRSource","makeHttpSource","makeRemoteSource","forceXHR","clientOptions","FileReaderSource","file","blob","event","makeFileReaderSource","getFieldTypeLength","fieldType","parseGeoKeyDirectory","rawGeoKeyDirectory","geoKeyDirectory","location","count","getValues","dataSlice","values","readMethod","fieldTypeLength","ImageFileDirectory","nextIFDByteOffset","GeoTIFFImageIndexError","GeoTIFFBase","resX","resY","bbox","firstImage","usedImage","imageCount","imgBBox","oX","oY","rX","rY","usedBBox","allImages","image","subfileType","newSubfileType","imgResX","imgResY","imageResX","imageResY","GeoTIFF","firstIFDOffset","fallbackSize","entrySize","offsetSize","numDirEntries","byteSize","entryCount","fieldTag","typeCount","fieldValues","valueOffset","actualOffset","fieldDataSlice","previousIfd","ifd","hasNext","detectionString","heuristicAreaSize","metadataSize","fullString","headerData","BOM","magicNumber","fromUrl","fromBlob","DeferredPromise","parsePerkinElmerChannels","images","_a","_b","_c","channels","imageDescription","channelName","channelColor","channelRGB","v","Converters","input","rgbaRaster","patchOSDImageJob","$","ImageJob","self","selfAbort","blb","BlobBuilder","bb","src","successful","completeJob","loader","job","callback","nextJob","_this","complete","jobOptions","newJob","_GeoTIFFTileSource","__publicField","level","levelScale","levelnum","ts","context","dataURL","defaultTileWidth","defaultTileHeight","fullWidth","fullHeight","acc","im","w","numPowersOfTwo","levelsToUse","scale","levelImages","prevScale","_d","_e","startTime","abortSignal","qptiffXML","canvas","ctx","arr","rgb","imageData","photometricInterpretation","globals.photometricInterpretations","tiff","error","OpenSeadragon","fileExtension","tolerance","accumulator","exists","set","channel","GeoTIFFTileSource","enableGeoTIFFTileSource","global","factory","this"],"mappings":"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R,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA;AAAA,EAGR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA,EACR,KAAQ;AAAA;AAAA,EAGR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAAQ;AAAA,EACR,OAA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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,27,28,29,30]}